<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>商圏市場テスト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body, #map { height: 100%; margin: 0; }
    .panel {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      width: 460px; max-height: calc(100% - 20px); overflow: auto;
      background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.15);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
      padding: 12px 14px;
    }
    .row { display:flex; justify-content:space-between; gap:8px; padding:6px 0; border-bottom:1px solid #eee; }
    .row:last-child { border-bottom:none; }
    .muted { color:#666; font-size:12px; }
    .code { font-family: ui-monospace, Consolas, monospace; }
    .btns { display:flex; gap:8px; margin:8px 0 4px; flex-wrap: wrap; }
    button { border:1px solid #ddd; background:#fafafa; padding:8px 12px; border-radius:10px; cursor:pointer; transition: all .15s ease; }
    button:hover { background:#f0f0f0; }
    button:disabled { opacity:.5; cursor:not-allowed; filter: grayscale(20%); }

    .btn-stop.emph { background: linear-gradient(180deg, #ef4444, #dc2626); color:#fff; border-color:#b91c1c; box-shadow: 0 0 0 2px rgba(239,68,68,.15), 0 8px 18px rgba(220,38,38,.35); }
    .btn-stop.emph:hover { filter: brightness(1.05); }
    .btn-stop.emph:active { transform: translateY(1px); }
    .btn-stop.emph .pulse { display:inline-block; width:8px; height:8px; margin-right:6px; border-radius:999px; background:#fff; animation: pulse 1s ease-in-out infinite; vertical-align: -1px; }
    @keyframes pulse { 0%{opacity:.55; transform: scale(.9);} 50%{opacity:1; transform: scale(1);} 100%{opacity:.55; transform: scale(.9);} }

    .stack { display:flex; flex-direction:column; gap:8px; margin:8px 0 4px; }
    .stack input[type="text"],
    .stack input[type="number"],
    .stack input[type="search"],
    .stack input[type="tel"],
    .stack input[type="email"],
    .stack button,
    .stack select {
      width:100%;
    }
    .stack input, #budgetInput, #copiesInput, #distInput, #targetAge, #targetAgeMale, #targetAgeFemale, #targetIncome { text-align:right; }

    .hit { background:#ecfdf5; border-color:#10b981!important; box-shadow:0 0 0 2px rgba(16,185,129,.15) inset; }
    .hitText { color:#059669; font-weight:600; }

    .overlay {
      position: fixed; inset: 0; background: rgba(255,255,255,.88);
      display: none; align-items: center; justify-content: center; flex-direction: column;
      z-index: 9999; backdrop-filter: blur(2px);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
    }
    .spinner { width: 54px; height: 54px; border-radius: 50%; border: 6px solid #e5e7eb; border-top-color: #3b82f6; animation: spin 1s linear infinite; margin-bottom: 12px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .progress { width: 280px; height: 10px; background:#eef2f7; border-radius: 999px; overflow: hidden; margin-top: 8px; box-shadow: inset 0 0 1px rgba(0,0,0,.08); }
    .progress > div { height: 100%; width: 0%; background:#3b82f6; transition: width .15s ease; }
    .overlay .muted { font-size: 12px; color:#6b7280; margin-top:6px; }

    /* 媒体計テーブルの 2～4列（件数・部数合計・料金合計）を右寄せ */
    #mediaStats table { width: 100%; border-collapse: collapse; }
    #mediaStats th, #mediaStats td { padding: 4px 8px; }
    #mediaStats th:nth-child(2),
    #mediaStats th:nth-child(3),
    #mediaStats th:nth-child(4),
    #mediaStats td:nth-child(2),
    #mediaStats td:nth-child(3),
    #mediaStats td:nth-child(4) {
      text-align: right;
    }

    .media-row-disabled {
      opacity: 0.45;
    }
    .media-toggle {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      white-space: nowrap;
    }
    .media-toggle.off {
      background: #f3f4f6;
      color: #6b7280;
      border-style: dashed;
      opacity: 0.9;
    }

    /* 部数（=配布量）を媒体ごとに倍率調整するスライダー */
    .media-scale-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    input.media-scale {
      width: 120px;
    }
    .media-scale-val {
      font-size: 11px;
      color: #374151;
      min-width: 44px;
      text-align: right;
      user-select: none;
    }
    .media-scale-wrap.disabled {
      opacity: 0.6;
    }

    #mediaStats tbody tr.media-row {
      cursor: pointer;
      transition: background-color .12s ease, transform .06s ease;
    }
    #mediaStats tbody tr.media-row:hover {
      background-color: #f9fafb;
    }
    #mediaStats tbody tr.media-row:active {
      transform: translateY(1px);
    }

    .type-box {
      margin: 8px 0 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .type-box label {
      font-size: 12px;
      color: #374151;
      font-weight: 600;
    }
    #typeSelect {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 6px 8px;
      width: 100%;
      font-size: 13px;
      background: #fafafa;
    }


    #originName {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 6px 8px;
      width: 100%;
      font-size: 13px;
      background: #fafafa;
    }

    /* ★追加：路線セレクト */
    #lineSelect {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 6px 8px;
      width: 100%;
      font-size: 13px;
      background: #fafafa;
    }

    #typeList {
      font-size: 12px;
      margin-top: 4px;
    }
    #typeList table {
      width: 100%;
      border-collapse: collapse;
    }
    #typeList th,
    #typeList td {
      padding: 3px 4px;
      border-bottom: 1px solid #eee;
    }
    #typeList th {
      text-align: left;
      background: #f9fafb;
    }
    #typeList td:nth-child(2),
    #typeList td:nth-child(3),
    #typeList td:nth-child(4),
    #typeList td:nth-child(5) {
      text-align: right;
    }

    .type-metrics-box {
      margin-top: 6px;
      padding: 8px 10px;
      background: #f9fafb;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
    }
    .type-metrics-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-top: 4px;
    }
    .type-metrics-label {
      font-size: 11px;
      color: #4b5563;
    }
    .type-metrics-value {
      font-size: 20px;
      font-weight: 700;
    }

    .type-metrics-note {
      margin-top: 6px;
      font-size: 11px;
      color: #4b5563;
      line-height: 1.5;
    }
    .type-metrics-note ul {
      padding-left: 18px;
      margin: 4px 0;
    }
    .type-metrics-note li {
      margin: 2px 0;
    }


    .view-status {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 30;

      display: flex;
      align-items: center;
      gap: 6px;

      padding: 4px 10px;
      border-radius: 999px;

      background: rgba(17,24,39,.94);   /* 半透明のダーク背景 */
      color: #f9fafb;
      font-size: 11px;

      border: 1px solid rgba(15,23,42,.7);
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
    }
    .view-status-actions {
      display: flex;
      gap: 4px;
      margin-left: 8px;
    }
    .view-status button {
      border-radius: 999px;
      border: 1px solid rgba(156,163,175,.9);
      background: rgba(31,41,55,.95);
      color: #e5e7eb;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
    }
    .view-status button:hover:not(:disabled) {
      background: rgba(55,65,81,1);
    }
    .view-status button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ★ 1件以上選択されているときの強調色 */
    .view-status button.is-active {
      border-color: transparent;
      background: #2563eb;
      color: #fff;
    }
    .view-status button.is-active:hover:not(:disabled) {
      background: #1d4ed8;
    }

    .view-status button.is-active {
      border-color: transparent;
      background: #2563eb; /* 好きな色に変えてOK（青） */
      color: #fff;
    }
    .view-status button.is-active:hover:not(:disabled) {
      background: #1d4ed8;
    }

    /* ★ ノブ（白丸）を非表示にする */
    .click-mode-toggle .toggle-knob {
      display: none;
    }

    /* ★ 左側の余白を普通のボタン用に調整 */
    .click-mode-toggle {
      padding: 2px 10px;  /* ← もともと 2px 10px 2px 26px だったところ */
    }

    .click-mode-toggle .toggle-text {
      font-size: 11px;
    }
    .click-mode-toggle.is-select,
    .click-mode-toggle.is-center {
      border-color: transparent;
      color: #fff;
    }

    /* 町を選択モード（緑） */
    .click-mode-toggle.is-select {
      background: #059669;              /* ボタン全体を緑 */
    }
    .click-mode-toggle.is-select .toggle-knob {
      transform: translateX(0);
      background: #ecfdf5;              /* ノブは薄い緑 */
    }

    /* 中心点移動モード（青） */
    .click-mode-toggle.is-center {
      background: #2563eb;              /* ボタン全体を青 */
    }
    .click-mode-toggle.is-center .toggle-knob {
      transform: translateX(12px);
      background: #eff6ff;              /* ノブは薄い青 */
    }

    .view-pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 600;
    }
    .view-pill-base {
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }
    .view-pill-media {
      background: #fef3c7;
      color: #b45309;
      border: 1px solid #fed7aa;
    }
    .view-status-name {
      font-weight: 600;
    }
    .view-toggle-active {
      border-color: #3b82f6;
      background: #eff6ff;
      color: #1d4ed8;
    }
    /* === 自動選択ブロック（目標＋ボタン） === */
    .auto-block {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    .auto-block-header {
      font-size: 12px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .auto-block-header::before {
      content: "";
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #3b82f6;
    }
    .auto-block.has-goal {
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59,130,246,.16);
      background: #eff6ff;
    }
    .auto-targets-main {
      margin-top: 4px;
    }
    .auto-btns {
      margin-top: 8px;
    }

    /* 目標入力時に「自動選択」ボタンを強調 */
    #runAutoBtn.auto-emph {
      background: linear-gradient(180deg, #3b82f6, #1d4ed8);
      color: #fff;
      border-color: #1d4ed8;
      box-shadow:
        0 0 0 2px rgba(59,130,246,.15),
        0 10px 25px rgba(37,99,235,.35);
      font-weight: 600;
      transform: translateY(-0.5px);
    }
    #runAutoBtn.auto-emph:hover {
      filter: brightness(1.05);
      transform: translateY(0);
    }
    #runAutoBtn.auto-emph:active {
      transform: translateY(1px);
      box-shadow:
        0 0 0 2px rgba(59,130,246,.18),
        0 4px 12px rgba(37,99,235,.4);
    }

    /* 自動選択後に「最適組み合わせ」「最適予算」を強調 */
    .opt-emph {
      position: relative;
      background: linear-gradient(180deg, #f59e0b, #d97706);
      color: #111827;
      border-color: #b45309;
      box-shadow:
        0 0 0 2px rgba(245,158,11,.22),
        0 10px 22px rgba(217,119,6,.28);
      font-weight: 700;
      animation: optPulse 1.15s ease-in-out infinite;
    }
    .opt-emph:hover { filter: brightness(1.03); }
    .opt-emph:active { transform: translateY(1px); }
    @keyframes optPulse {
      0%   { box-shadow: 0 0 0 2px rgba(245,158,11,.20), 0 10px 22px rgba(217,119,6,.22); }
      50%  { box-shadow: 0 0 0 4px rgba(245,158,11,.32), 0 14px 30px rgba(217,119,6,.30); }
      100% { box-shadow: 0 0 0 2px rgba(245,158,11,.20), 0 10px 22px rgba(217,119,6,.22); }
    }

    /* 文字を消して区切り線だけ出す */
    .auto-hint {
      margin-top: 10px;
      border-top: 1px solid #e5e7eb;
    }

    /* 提案レポート設定ブロック */
    .section-block {
      margin-top: 6px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 6px 10px;
    }

    /* summary 部分の見た目 */
    .section-block > summary {
      list-style: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      color: #374151;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* デフォルトの三角マーカーを消す（Chrome系） */
    .section-block > summary::-webkit-details-marker {
      display: none;
    }

    /* 開いているときは少しだけ浮かせる */
    .section-block[open] {
      box-shadow: 0 1px 4px rgba(0,0,0,.04);
    }

    /* summary の下に仕切りラインを入れるための内側ボックス */
    .section-block-inner {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid #e5e7eb;
    }

    /* 提案レポート準備完了時のボタン強調 */
    #proposalReportBtn.report-ready {
      background: linear-gradient(180deg, #10b981, #059669);
      color: #fff;
      border-color: #047857;
      box-shadow:
        0 0 0 2px rgba(16,185,129,.18),
        0 10px 24px rgba(16,185,129,.35);
      font-weight: 600;
      transform: translateY(-0.5px);
    }
    #proposalReportBtn.report-ready:hover {
      filter: brightness(1.05);
      transform: translateY(0);
    }
    #proposalReportBtn.report-ready:active {
      transform: translateY(1px);
      box-shadow:
        0 0 0 2px rgba(16,185,129,.22),
        0 4px 12px rgba(16,185,129,.4);
    }

    /* 属性選択：リストボックス風 */
    .attr-listbox {
      margin-top: 4px;
      max-height: 220px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 2px 3px;       /* ← 4px 6px から少し狭く */
      overflow-y: auto;
    }

    /* 行内のチェックボックスと文字の距離・上下左右の余白を詰める */
    .attr-row {
      display: flex;
      align-items: center;
      gap: 3px;               /* ← 6px → 3px に */
      padding: 1px 2px;       /* ← 3px 4px → 1px 2px に */
      border-radius: 4px;
      cursor: pointer;
    }

    .attr-row:hover {
      background: #eef2ff;
    }
    .attr-row-label {
      font-size: 12px;
      color: #111827;
      flex: 1;
    }
    
    .attr-row input {
      margin: 0;
      flex-shrink: 0;         /* チェックボックスが縮まないように */
    }

    .attr-metrics {
      margin-top: 6px;
      font-size: 11px;
      color: #374151;
    }
    .attr-metrics-title {
      font-size: 11px;
      color: #4b5563;
      margin: 2px 0 2px;
    }
    .attr-metrics-scroll {
      max-height: 180px;
      overflow: auto;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      margin-top: 2px;
    }
    .attr-metrics table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      min-width: 420px;
    }
    .attr-metrics th,
    .attr-metrics td {
      border: 1px solid #e5e7eb;
      padding: 2px 4px;
      white-space: nowrap;
    }
    .attr-metrics th {
      background: #eef2ff;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .attr-metrics td.num {
      text-align: right;
    }

    .attr-metrics-group {
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    .attr-metrics-group-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      color: #111827;
    }


    #attrMetrics table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    #attrMetrics th,
    #attrMetrics td {
      border-bottom: 1px solid #eee;
      padding: 2px 4px;
    }
    #attrMetrics th {
      background: #f9fafb;
    }
    #attrMetrics td.num {
      text-align: right;
    }
    #attrMetrics td.center {
      text-align: center;
    }
    #attrMetrics input[type="checkbox"] {
      vertical-align: middle;
    }
    /* ================================
       下部の集計系表示を丸ごと非表示にする
       ・選択
       ・平均年齢などのサマリ(topStats)
       ・媒体（媒体名別・選択合計）
       ・すべての数値列（合計・平均）
       ・選択中の町丁目（最大50件）
       ================================ */
    #summary,
    #topStats,
    details:has(#mediaStats),
    details:has(#allStats),
    details:has(#picked) {
      display: none;
    }


  

    /* ===== Busy overlay (center) ===== */
    #busyOverlay.busy-overlay{
      position: fixed;
      inset: 0;
      z-index: 99999;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* don't block slider dragging */
      user-select: none;
    }
    #busyOverlay.busy-overlay.show{ display: flex; }
    #busyOverlay .busy-card{
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 18px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 14px;
      line-height: 1.2;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    #busyOverlay .busy-spinner{
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.35);
      border-top-color: #fff;
      animation: busySpin 0.8s linear infinite;
      flex: 0 0 auto;
    }
    @keyframes busySpin { to { transform: rotate(360deg); } }
</style>
</head>
<body>
  <div id="map"></div>
  <!-- ★ 現在ビュー表示（地図上の別枠） -->
  <div id="viewStatus" class="view-status"></div>

  
  <!-- ★ Busy overlay（重い更新時に画面中央へ表示） -->
  <div id="busyOverlay" class="busy-overlay" aria-live="polite" aria-label="更新中">
    <div class="busy-card">
      <div class="busy-spinner" aria-hidden="true"></div>
      <div class="busy-text">更新中…</div>
    </div>
  </div>
<div id="overlay" class="overlay">
    <div class="spinner"></div>
    <div id="overlayTitle" style="font-weight:700;margin-bottom:4px;">初期計算を準備中…</div>
    <div id="overlayMsg" class="muted">CSVと地図の読み込みを待機中</div>
    <div class="progress" style="margin-top:12px;"><div id="overlayBar"></div></div>
    <div id="overlaySub" class="muted"></div>
  </div>

  <div class="panel">
    <div><strong>商圏市場テスト ver.2.7.2</strong></div>

    <!-- ★ 提案レポート用ヘッダ＋出力（折りたたみボックス） -->
    <details id="reportHeaderBlock" class="section-block">
      <summary>提案レポート設定・出力</summary>

      <div class="section-block-inner">
        <div class="stack" style="margin-top:6px;">
          <input id="clientNameInput" type="text" placeholder="提案先（クライアント名など）"
                style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
          <input id="planTitleInput" type="text" placeholder="案件名 / キャンペーン名"
                style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
          <input id="periodInput" type="text" placeholder="配布期間（例：2026年3月〜4月）"
                style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
        </div>

        <div class="btns" style="margin-top:6px;">
          <button id="exportReportBtn">レポート出力（CSV）</button>
          <button id="proposalReportBtn">提案レポート（印刷 / PDF）</button>
        </div>
      </div>
    </details>

    <div class="type-box">

      <label for="typeSelect">業態別 SHAP / 貢献度</label>
      <select id="typeSelect">
        <option value="">業態を選択...</option>
      </select>

      <!-- ★ 再計算ボタン -->
      <div style="display:flex; gap:8px; margin-top:4px;">
        <button id="typeRecalcBtn" type="button">業態指標を再計算</button>
      </div>

      <div id="typeList" class="muted">
        業態を選ぶと、媒体ごとの SHAP / 貢献度 と、選択中配布町ベースの 推測視認率 / 来店期待値 を表示します。
      </div>
    </div>



    <!-- ★ 目標入力＋自動選択ブロック -->
    <div id="autoBlock" class="auto-block">
      <div class="auto-block-header">
        目標設定 ＆ 自動選択
      </div>

      <!-- 料金・部数・距離 -->
      <div class="stack auto-targets-main">
        <input id="budgetInput" type="text" inputmode="numeric"
               placeholder="料金目標（万円）"
               style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
        <input id="copiesInput" type="text" inputmode="numeric"
               placeholder="部数目標（万部）"
               style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
        <input id="distInput" type="text" inputmode="numeric"
               placeholder="距離目標（km）※起点はクリック or 自動決定"
               style="border:1px solid #ddd;border-radius:8px;padding:6px 10px;">
      </div>

      <!-- ★追加：鉄道路線（選択すると、その路線の駅がある町も候補に追加） -->
      <div class="type-box" style="margin-top:8px;">
        <label for="lineSelect">鉄道路線（候補に追加）</label>
        <select id="lineSelect" disabled>
          <option value="">駅マスタ読込中...</option>
        </select>
        <div id="lineSelectHint" class="muted" style="font-size:11px;">
          路線を選ぶと、その路線の駅がある町も「隣接候補」と同じ扱いで自動選択の候補になります（未選択なら従来通り）。
        </div>
      </div>


      <!-- 属性選択ブロック：町マスタの「属性」を含む列を自動検出してチェックボックス化 -->
      <details open style="margin-top:6px;">
        <summary>重視する属性を選択</summary>
        <div id="attributeSelectBox" class="stack muted" style="font-size:12px;">
          町マスタの列名から「属性」を含む列を自動検出して、ここにチェックボックスを表示します。
        </div>
      </details>

      <!-- ★ 属性比較表示エリア（※別グループ） -->
      <div class="attr-metrics-group">
        <div class="attr-metrics-group-title">
          選択した属性の媒体別属性値
        </div>
        <div id="attrMetrics" class="attr-metrics muted"></div>

        <!-- ★追加：最適組み合わせに絞る（type_master_all.csv の組み合わせから最良を選び、他媒体を除外） -->
        <div class="stack" style="margin-top:6px;">
          <button id="keepBestComboBtn" type="button">最適組み合わせに絞る</button>
          
          <button id="applyOptimalBudgetBtn" type="button">最適予算配分にする</button>
<div id="keepBestComboHint" class="muted" style="font-size:11px;line-height:1.35;"></div>
        </div>
      </div>



      <div class="btns auto-btns">
        <button id="runAutoBtn" type="button" class="auto-emph">
          自動選択
        </button>
        <button id="stopBtn" class="btn-stop" disabled>
          <span class="pulse" style="display:none"></span>自動選択を停止
        </button>
      </div>


      <!-- 文言は削除して、区切り線用の空の div にする -->
      <div class="auto-hint"></div>
    </div> 




    <div id="selectMsg" class="muted"></div>

    <div id="summary" class="row"><span>状態</span><span>CSV読み込み中...</span></div>
    <div id="topStats"></div>

    <details open>
      <summary>媒体（媒体名別・選択合計）</summary>
      <div id="mediaStats"></div>
    </details>

    <details>
      <summary>すべての数値列（合計・平均）</summary>
      <div id="allStats"></div>
    </details>

    <details>
      <summary>選択中の町丁目（最大50件を表示）</summary>
      <div id="picked"></div>
    </details>
  </div>

  <script>
    // UI確認用：true なら初期計算あり / false なら初期計算スキップ
    const ENABLE_PRECOMPUTE = true;   // 普段は true、UIだけ見るときは false に

    // ========= 設定 =========
    const GEOJSON_URL = "./aichi_nearpoint50m_withcode.geojson";
    const CSV_TOWN    = "./town_master.csv";
    const CSV_MEDIA   = "./media_master.csv";
    const CODE_KEY      = "町丁目コード";
    const POP_TOTAL_KEY = "人口総数";
    const HH_TOTAL_KEY  = "世帯総数";
    const CAR_AVG_KEY   = "1世帯あたり乗用車保有台数";
    const STORE_KEY     = "店cd";
    // CSVの列名ゆれ対策（媒体マスタ側の「エリアコード/店CD」候補）
    const MEDIA_AREA_KEYS = [
      "エリアコード", "エリアCD", "エリアＣＤ", "エリアｃｄ",
      "配布エリアコード", "配布エリアCD", "配布エリアＣＤ",
      "店cd", "店CD", "店ＣＤ", "店ｃｄ", "店舗cd", "店舗CD",
      "area_code", "area_cd", "AREA_CODE", "AREA_CD", "AreaCode", "AreaCd"
    ];

    // 媒体マスタ行から「店CD/エリアコード」を取得（列名ゆれ対応）
    function getStoreCdFromRow(r){
      if (!r) return "";
      for (const k of MEDIA_AREA_KEYS){
        const v = r[k];
        if (v != null) {
          const s = String(v).trim();
          if (s !== "") return s;
        }
      }
      return "";
    }

    const CSV_TYPE   = "./type_master_all.csv";
    const sleep = (ms=0) => new Promise(resolve => setTimeout(resolve, ms));
    const CSV_STATION = "./station_master.csv";

    // ==== 四隅(bbox)カラム定義（CSV優先） ====
    const BBOX_KEYS = {
      minLon: "bbox_min_lon",
      minLat: "bbox_min_lat",
      maxLon: "bbox_max_lon",
      maxLat: "bbox_max_lat",
    };
    let bboxCsvByCode = new Map();
    let featureBboxByCode = new Map();

    // ★ 属性選択用（town_master の列名から「属性」を含む列を自動検出）
    let attributeColumnKeys = [];


    // ---- フロンティア抑制 ----
    const SEED_LIMIT   = 200;
    const MAX_SCAN     = 200;

    const USE_CORNER_ADJACENCY = true;
    let cornerAdjCache = new Map();
    let exhaustedCornerBase = new Map();

    let seedLRU = new Map();
    let seedTick = 0;
    function touchSeed(code){ seedLRU.set(String(code), ++seedTick); }

    function escHtml(s) {
      return String(s ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }


    function resetFrontierCaches() {
      neighborPtr.clear();
      neighborCache.clear();
      cornerAdjCache.clear();
      exhaustedCornerBase.clear();
      seedLRU.clear();
      seedTick = 0;
    }

    // ========= ユーティリティ =========
    const $ = (id) => document.getElementById(String(id).replace(/^#/, ''));
    let allFeatures = [];
    let lastClickLngLat = null;

    const fixed1 = (x) => (Number.isFinite(Number(x)) ? (Math.round(Number(x)*10)/10).toFixed(1) : "0.0");
    const fmt    = (v) => (typeof v === "number" && isFinite(v)) ? v.toLocaleString() : (v ?? "");
    const fmtU   = (v, unit="") => (typeof v === "number" && isFinite(v)) ? `${v.toLocaleString()}${unit}` : (v ?? "");
    const z2h = (s="") => s.replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0)-0xFEE0)).replace(/[－ー―‐]/g, "-").replace(/[〜～]/g, "～");
    function distMeters(a, b) {
      const [lon1, lat1] = a, [lon2, lat2] = b;
      const toRad = (d) => d * Math.PI / 180;
      const xm = (lon2 - lon1) * Math.cos(toRad((lat1 + lat2) / 2)) * 111320;
      const ym = (lat2 - lat1) * 111320;
      return Math.hypot(xm, ym);
    }

    // ★追加：この町が「路線のどれか駅」にどれだけ近いか（最短距離）
    function getRailMinDistForTown(code){
      const k = String(code);
      if (!activeLineStationCentroids || activeLineStationCentroids.length === 0) return null;

      if (railMinCache.has(k)) return railMinCache.get(k);

      const p = PRE.get(k);
      const cent = p?.centroid || centroidOf(k);
      if (!cent) { railMinCache.set(k, null); return null; }

      let best = Infinity;
      for (const s of activeLineStationCentroids){
        const d = distMeters(cent, s);
        if (d < best) best = d;
      }

      railMinCache.set(k, best);
      return best;
    }


    const toNumber = (v) => {
      if (v == null) return 0;
      const s = String(v).replace(/[^\d.-]/g, "");
      const n = Number(s);
      return Number.isFinite(n) ? n : 0;
    };

    function formatPreserveDecimals(raw, unit="") {
      const str = String(raw ?? "");
      if (!/[0-9]/.test(str)) return str;
      let cleaned = str.replace(/[^\d.-]/g, "");
      cleaned = cleaned.replace(/(?!^)-/g, "");
      const firstDot = cleaned.indexOf(".");
      if (firstDot !== -1) {
        cleaned = cleaned.slice(0, firstDot + 1) + cleaned.slice(firstDot + 1).replace(/\./g, "");
      }
      const isNeg = cleaned.startsWith("-");
      const unsigned = isNeg ? cleaned.slice(1) : cleaned;
      let intPart = unsigned, fracPart = "";
      const dotIdx = unsigned.indexOf(".");
           if (dotIdx !== -1) {
        intPart = unsigned.slice(0, dotIdx);
        fracPart = unsigned.slice(dotIdx + 1);
      }
      const intNum = Number(intPart.replace(/[^\d]/g, "") || "0");
      const grouped = intNum.toLocaleString();
      const signed = (isNeg ? "-" : "") + grouped + (fracPart ? "." + fracPart : "");
      return signed + unit;
    }

    function setupSmartFormatter(id, unit="", { onCommit } = {}) {
      const el = document.getElementById(id); if (!el) return;
      const applyFormat = () => {
        if (el.value === "") return;
        el.value = formatPreserveDecimals(el.value, unit);
        onCommit?.(el.value);
      };
      el.addEventListener("focus", () => {
        const uRe = new RegExp(unit.replace(/([.*+?^=!:${}()|[\]\\/])/g, "\\$1")+"$");
        const raw = String(el.value).replace(uRe, "");
        el.value = raw.replace(/,/g, "");
        setTimeout(() => el.select(), 0);
      });
      el.addEventListener("blur", applyFormat);
      el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
    }

    // ★ 目標入力 or 属性選択があれば自動選択ボタンを強調
    function hasAnyGoalInput() {
      // 料金・部数・距離のどれかに値が入っていれば true
      const ids = ["budgetInput", "copiesInput", "distInput"];
      const hasNumericGoal = ids.some(id => {
        const el = $(id);
        if (!el) return false;
        const v = el.value ?? "";
        return toNumber(v) > 0;
      });

      // 属性チェックボックスが1つでも ON なら true
      const box = $("attributeSelectBox");
      const hasAttr =
        box && box.querySelector(".attr-checkbox:checked") ? true : false;

      return hasNumericGoal || hasAttr;
    }



    function updateAutoButtonHighlight() {
      const hasGoal = hasAnyGoalInput();
      const autoBtn = $("runAutoBtn");
      const block   = $("autoBlock");

      // ボタンは常に点灯状態
      if (autoBtn) {
        autoBtn.classList.add("auto-emph");
      }
      // 自動選択ブロックの枠だけは「目標あり」で強調しておく
      if (block) {
        block.classList.toggle("has-goal", hasGoal);
      }
    }

    
    // ★ 自動選択後に「最適組み合わせ」「最適予算」ボタンを強調（全て解除ボタンで解除）
let _optEmphOn = false;

function _applyOptEmphClass(){
  const b1 = document.getElementById('keepBestComboBtn');
  const b2 = document.getElementById('applyOptimalBudgetBtn');
  if (b1) b1.classList.toggle('opt-emph', !!_optEmphOn);
  if (b2) b2.classList.toggle('opt-emph', !!_optEmphOn);
}

function clearOptimizeButtonEmph(){
  _optEmphOn = false;
  _applyOptEmphClass();
}

function emphasizeOptimizeButtons(){
  _optEmphOn = true;
  _applyOptEmphClass();
}


// 停止ボタンと自動実行フラグ
    let STOP = { requested: false };
    let IS_AUTO_RUNNING = false;

    // ★ 提案レポート HTML（1回目クリックで準備 → 2回目で開く）
    let pendingReportHtml = null;

    function setStopEnabled(on){
      const b = $("stopBtn"); if (!b) return;
      b.disabled = !on;
      b.classList.toggle("emph", !!on);
      const dot = b.querySelector('.pulse');
      if (dot) dot.style.display = on ? 'inline-block' : 'none';
      b.textContent = on ? "" : "自動選択を停止";
      if (on) {
        b.insertAdjacentHTML('afterbegin', '<span class="pulse"></span>');
        b.appendChild(document.createTextNode('自動選択を停止'));
      }
    }
    function beginAuto(){ IS_AUTO_RUNNING = true; STOP.requested = false; setStopEnabled(true); }
    function finishAuto(){ IS_AUTO_RUNNING = false; setStopEnabled(false); }
    function resetStop(){ STOP.requested = false; setStopEnabled(false); }

    $("stopBtn").addEventListener("click", () => {
      if ($("stopBtn").disabled) return;
      STOP.requested = true;
      setStopEnabled(false);
    });

    // 地理円
    function circlePolygon(center, radiusMeters, steps=256){
      const [lon, lat] = center;
      const coords = [];
      const rad = Math.PI/180;
      const cosLat = Math.cos(lat*rad) || 1e-9;
      for(let i=0;i<=steps;i++){
        const t = 2*Math.PI*i/steps;
        const dx = radiusMeters * Math.cos(t);
        const dy = radiusMeters * Math.sin(t);
        const dlon = dx / (111320 * cosLat);
        const dlat = dy / 111320;
        coords.push([lon + dlon, lat + dlat]);
      }
      return { type:"Feature", properties:{}, geometry:{ type:"Polygon", coordinates:[coords] } };
    }

    // 列検出
    function z2hBand(label="", fallbackWidth=5) {
      const t = z2h(label);
      if (/年齢不詳/.test(t)) return null;
      let m = t.match(/(男|女)?\s*([0-9]+)\s*～\s*([0-9]+)\s*歳人口/);
      if (m) return { lo: Number(m[2]), hi: Number(m[3]) };
      m = t.match(/(男|女)?\s*([0-9]+)\s*歳以上人口/);
      if (m) return { lo: Number(m[2]), hi: Number(m[2]) + fallbackWidth };
      return null;
    }
    function parseAgeBand(label="", fallbackWidth=5) { return z2hBand(label,fallbackWidth); }
    function parseIncomeBand(label="", fallbackWidth=200) {
      const t = z2h(label);
      let m = t.match(/年収\s*([0-9]+)\s*～\s*([0-9]+)\s*万円未満世帯数/);
      if (m) return { lo: Number(m[1]), hi: Number(m[2]) };
      m = t.match(/年収\s*([0-9]+)\s*万円未満世帯数/);
      if (m) return { lo: 0, hi: Number(m[1]) };
      m = t.match(/年収\s*([0-9]+)\s*万円以上世帯数/);
      if (m) return { lo: Number(m[1]), hi: Number(m[1]) + fallbackWidth };
      return null;
    }
    function detectNumericKeys(rows) {
      if (!rows?.length) return [];
      const keys = Object.keys(rows[0]);
      const sample = rows.slice(0, 500);
      const isNumericish = (v) => {
        if (v === null || v === undefined || v === "") return true;
        if (typeof v === "number") return Number.isFinite(v);
        if (typeof v === "string") {
          const n = Number(v.replace(/[^\d.-]/g, ""));
          return Number.isFinite(n);
        }
        return false;
      };
      return keys.filter(k => {
        let sawNumeric = false;
        for (const r of sample) {
          const v = r[k];
          if (v === null || v === undefined || v === "") continue;
          if (!isNumericish(v)) return false;
          const n = (typeof v === "number") ? v : Number(String(v).replace(/[^\d.-]/g, ""));
          if (Number.isFinite(n)) sawNumeric = true;
        }
        return sawNumeric;
      });
    }
    function detectIncomeWidth(keys) {
      const widths = {};
      for (const k of keys) {
        const b = parseIncomeBand(k, null);
        if (b && b.hi != null) {
          const w = b.hi - b.lo;
          if (w > 0) widths[w] = (widths[w] || 0) + 1;
        }
      }
      let best = null, cnt = -1;
      for (const w in widths) if (widths[w] > cnt) { cnt = widths[w]; best = Number(w); }
      return best || 200;
    }

    // ★ town_master から「属性候補の列」を検出
    function detectAttributeColumnsFromTownMaster() {
      if (!townIndex || !townIndex.size) return [];

      const sampleRows = Array.from(townIndex.values()).slice(0, 200);
      if (!sampleRows.length) return [];

      const first = sampleRows[0];
      const allKeys = Object.keys(first);

      // 明らかに除外したい列
      const exclude = new Set([
        CODE_KEY,
        "市区町村名",
        "町丁目名",
        POP_TOTAL_KEY,
        HH_TOTAL_KEY,
        CAR_AVG_KEY,
        BBOX_KEYS.minLon,
        BBOX_KEYS.minLat,
        BBOX_KEYS.maxLon,
        BBOX_KEYS.maxLat
      ]);

      // 「数値っぽいか？」だけチェックする関数（かなりゆるめ）
      const isNumericish = (v) => {
        if (v === null || v === undefined || v === "") return true;
        if (typeof v === "number") return Number.isFinite(v);
        const s = String(v).replace(/[^\d.-]/g, "");
        if (!s) return false;
        const n = Number(s);
        return Number.isFinite(n);
      };

      const cols = allKeys.filter(k => {
        if (exclude.has(k)) return false;

        // サンプル行の中で「非数値」が混じっていたら外す
        for (const row of sampleRows) {
          if (!isNumericish(row[k])) return false;
        }
        return true;
      });

      // 万一なにも取れなかったら、「除外以外全部」を出すセーフティ
      if (!cols.length) {
        return allKeys.filter(k => !exclude.has(k));
      }

      return cols;
    }




    // 地図
    const style = {
      "version": 8,
      // ★ これを追加
      "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",

      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256,
          "attribution": "© OpenStreetMap contributors"
        }
      },
      "layers": [
        { "id": "osm", "type": "raster", "source": "osm" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style,
      center: [136.8816, 35.1709],
      zoom: 12,
      // ★ 地図画像を toDataURL() で抜くために必須
      preserveDrawingBuffer: true
    });

    map.addControl(new maplibregl.NavigationControl(), "top-right");

    // 地図の再描画完了（idle）を待つヘルパー
    function waitMapIdle() {
      return new Promise((resolve) => {
        if (!map || typeof map.once !== "function") {
          resolve();
          return;
        }

        const onIdle = () => {
          if (typeof map.off === "function") {
            map.off("idle", onIdle);
          }
          resolve();
        };

        map.once("idle", onIdle);

        if (typeof map.triggerRepaint === "function") {
          map.triggerRepaint();
        }
      });
    }


    // データ
    let townIndex = null;
    let mediaIndex = null;  
    let storeToCodes = null;
    let numericKeys = [];
    let incomeWidthFallback = 200;

    // ★ 業態マスタ用
    let typeMasterRows = [];
    let typeMasterByGyotai = new Map();
    let typeMasterByGyotaiCombo = new Map(); // gyotai -> comboKey -> {rows, meta}

    // ★媒体名 -> 分類（媒体カテゴリ）
    let mediaCategoryByName = new Map();
    let readyTown=false, readyMedia=false, readyGeo=false;

    // ★ 駅マスタ用（station_master.csv）
    let stationRows = [];
    let stationByTown = new Map();   // town_code -> [{line_name, station_name}, ...]
    let stationByName = new Map();   // station_name -> [{line_name, town_code}, ...]
    let readyStation = false;


    // ★追加：路線 -> 町コード集合
    let stationByLine = new Map();   // line_name -> Set(town_code)

    // ★追加：鉄道路線選択（候補追加）
    let activeLineName = "";
    let activeLineTownSet = new Set();

    let activeLineStationCentroids = [];   // Array<[lng,lat]>
    let railMinCache = new Map();          // town_code -> minDistanceToAnyStation (meters)


    function setActiveLine(lineName){
      activeLineName = String(lineName || "").trim();

      // 1) 「駅がある町」の集合（候補に追加する町）
      activeLineTownSet = new Set();
      if (activeLineName && stationByLine.has(activeLineName)) {
        for (const c of stationByLine.get(activeLineName)) activeLineTownSet.add(String(c));
      }

      // 2) ★追加：「路線の全駅（の町重心）」を作る
      activeLineStationCentroids = [];
      railMinCache = new Map();

      if (activeLineName && stationRows && stationRows.length) {
        const seen = new Set(); // station_name で重複排除（無い場合は town_code）
        for (const r of stationRows) {
          const ln = String(r["line_name"] ?? r["\ufeffline_name"] ?? r["路線名"] ?? "").trim();
          if (ln !== activeLineName) continue;

          const st = String(r["station_name"] ?? r["駅名"] ?? "").trim();
          const tc = String(r["town_code"] ?? r["町丁目コード"] ?? "").trim();
          if (!tc) continue;

          const key = st || tc;
          if (seen.has(key)) continue;
          seen.add(key);

          const cent = PRE.get(tc)?.centroid || centroidOf(tc);
          if (cent) activeLineStationCentroids.push(cent);
        }
      }

      // 3) 候補集合が変わるのでキャッシュをクリア
      neighborCache?.clear?.();
      neighborPtr?.clear?.();
      exhaustedCornerBase?.clear?.();

      // 4) ヒント更新
      const hint = $("lineSelectHint");
      if (hint) {
        hint.innerHTML = activeLineName
          ? `選択中：<b>${escHtml(activeLineName)}</b>（駅のある町: ${activeLineTownSet.size}件 / 駅数: ${activeLineStationCentroids.length}）<br>※候補の並びは「全駅から近い町」優先（最遠駅距離→平均距離→起点距離）`
          : `路線を選ぶと、その路線の駅がある町も「隣接候補」と同じ扱いで自動選択の候補になります（未選択なら従来通り）。`;
      }
      applyLineTownHighlight();         // ★路線の駅町を onLine=true にして強調
      map?.triggerRepaint?.();          // （任意）塗り更新を確実に
    }


    function getActiveLineTownCandidates(){
      return (activeLineName && activeLineTownSet && activeLineTownSet.size) ? activeLineTownSet : null;
    }

    // ★追加：候補町が「路線のどれか駅」にどれだけ近いか（最短距離）
    function getRailMinDistForTown(code){
      const k = String(code);
      if (!activeLineStationCentroids || activeLineStationCentroids.length === 0) return null;

      if (railMinCache.has(k)) return railMinCache.get(k);

      const centroid = PRE.get(k)?.centroid || centroidOf(k);
      if (!centroid) { railMinCache.set(k, null); return null; }

      let best = Infinity;
      for (const s of activeLineStationCentroids){
        const d = distMeters(centroid, s); // meters
        if (d < best) best = d;
      }
      railMinCache.set(k, best);
      return best;
    }


    function populateLineSelect(){
      const sel = $("lineSelect");
      if (!sel) return;

      const lines = [...stationByLine.keys()]
        .map(s => String(s || "").trim())
        .filter(Boolean)
        .sort((a,b)=>a.localeCompare(b,"ja"));

      if (!lines.length) {
        sel.innerHTML = `<option value="">（路線データなし）</option>`;
        sel.disabled = true;
        return;
      }

      const opts = [`<option value="">（未選択：隣接のみ）</option>`]
        .concat(lines.map(name => {
          const n = stationByLine.get(name)?.size || 0;
          return `<option value="${escHtml(name)}">${escHtml(name)}（町${n}件）</option>`;
        }));

      sel.innerHTML = opts.join("");
      sel.disabled = false;

      // 既に選択済みなら復元
      sel.value = activeLineName || "";

      // change handler（重複登録防止）
      if (!sel._boundLineChange) {
        sel.addEventListener("change", () => setActiveLine(sel.value));
        sel._boundLineChange = true;
      }

      // 初期ヒント
      setActiveLine(sel.value);
    }


    // ★ 基準町で選んだ町を起点に、
    //    媒体ごとの「同じ店cdが出ている町」を自動的に媒体選択セットに足す
    function autoExpandMediaFromBaseTown(baseCode) {
      if (!mediaIndex || !storeToCodes) return;

      const rowsForTown = mediaIndex.get(String(baseCode));
      if (!rowsForTown) return;

      for (const r of rowsForTown) {
        const mediaName = r["媒体名"] ?? "(名称不明)";
        const store = getStoreCdFromRow(r);
        if (!store) continue;


        // ★ 追加：対象外になっている媒体はスキップ
        if (!isMediaEnabled(mediaName)) continue;

        const codesForStore = storeToCodes.get(store);
        if (!codesForStore) continue;

        // この媒体の「選択町セット」を取得 or 作成
        let set = mediaViewByName.get(mediaName);
        if (!set) {
          set = new Set();
          mediaViewByName.set(mediaName, set);
        }

        // この店cdが出ている町を全部追加
        codesForStore.forEach(code => {
          set.add(String(code));
        });
      }
    }



    // 媒体名ごとの「全域に出ている町リスト」
    let mediaCodesAllByName = null;
    // ★追加：媒体名 → エリアコード → 町コード集合（全域）
    let mediaAreaToCodesAllByName = null;



    // ★ 媒体名ごとの ON/OFF 状態（true=対象 / false=対象外）
    let mediaEnabledByName = new Map();

    // ★追加：媒体ごとの部数/料金の倍率（1.0=100%）
    //   スライダーで調整し、集計・自動選択・業態指標にも反映
    let mediaScaleByName = new Map();


    // === ★目標到達ロック（部数/料金目標を維持するためのスライダー制御） ===
    const GOAL_LOCK = {
      enabled: false,
      targetYen: 0,
      targetCopies: 0,

      // ★全媒体合計で先に達した目標をゲージ基準にする
      // 'yen' | 'cps' | null
      basisMetric: null,

      // ロック対象の媒体（目標到達時に設定がある媒体だけ）
      activeMediaSet: new Set(),

      // 媒体ごとの「店CD/エリア順」(表示対象になり得る範囲だけ)
      areaOrderByMedia: new Map(),          // Map<mediaName, string[]>

      // 媒体ごとの「エリア追加 1つあたりの増分」(areaOrder と同じ順)
      areaGainByMedia: new Map(),           // Map<mediaName, Array<{yen:number,cps:number}>>

      // 媒体単独で目標達成できる（または取得できた）店CD数
      maxCountByMedia: new Map(),           // Map<mediaName, number>

      // 現在のスライダー値（店CD数）
      valueCountByMedia: new Map(),         // Map<mediaName, number>

      // ロック中に使う『最大集合』（媒体の全域など）
      maxSetByMedia: new Map(),             // Map<mediaName, Set<townCode>>

      // 目標到達時点の「基準町追加順」と「選択セット」のスナップショット
      baseTownOrderAtGoal: [],
      selectedAtGoal: new Set(),
    };

    function isGoalLockOn(){ return !!(GOAL_LOCK && GOAL_LOCK.enabled); }

    function clearGoalLock(){
      GOAL_LOCK.enabled = false;
      GOAL_LOCK.targetYen = 0;
      GOAL_LOCK.targetCopies = 0;
      GOAL_LOCK.basisMetric = null;
      GOAL_LOCK.activeMediaSet = new Set();
      GOAL_LOCK.areaOrderByMedia = new Map();
      GOAL_LOCK.areaGainByMedia = new Map();
      GOAL_LOCK.maxCountByMedia = new Map();
      GOAL_LOCK.valueCountByMedia = new Map();
      GOAL_LOCK.maxSetByMedia = new Map();
      GOAL_LOCK.baseTownOrderAtGoal = [];
      GOAL_LOCK.selectedAtGoal = new Set();
    }

    // 媒体×町 で料金・部数を取得（スケールは掛けない）
    function getTownYenCopiesForMedia(townCode, mediaName, areaCodeOpt){
      const code = String(townCode);
      const m = String(mediaName);
      const areaOpt = (areaCodeOpt != null && String(areaCodeOpt) !== "") ? String(areaCodeOpt) : null;
      let yen = 0, cps = 0;
      const rows = mediaIndex?.get(code) || [];
      for (const r of rows) {
        const nm = r["媒体名"] ?? "(名称不明)";
        if (String(nm) !== m) continue;
        if (areaOpt) {
          const a = getMediaAreaCodeFromRow(r, code);
          if (String(a) !== areaOpt) continue;
        }
        yen += toNumber(r["料金"]);
        cps += toNumber(r["部数"]);
      }
      return { yen, cps };
    }

    // ロック用：エリア（=店CD/エリアコード）1つ追加したときの増分を計算
    function computeAreaGainForMedia(mediaName, areaCode, maxSet){
      const m = String(mediaName);
      const codes = getCodesForAreaWithinMax(m, areaCode, maxSet);
      let yen = 0, cps = 0;
      for (const c of codes) {
        const t = getTownYenCopiesForMedia(c, m, areaCode);
        yen += t.yen;
        cps += t.cps;
      }
      return { yen, cps };
    }

    // 目標到達時点の状態から、媒体ごとの「単独達成 max」と「現在値」を作る
    function buildGoalLockFromCurrentSelection(targetYen, targetCopies, basisHint){
      const ty = Math.round(Number(targetYen) || 0);
      const tc = Math.round(Number(targetCopies) || 0);
      if (!(ty > 0 || tc > 0)) { clearGoalLock(); return; }

      clearGoalLock();
      GOAL_LOCK.enabled = true;
      GOAL_LOCK.targetYen = ty;
      GOAL_LOCK.targetCopies = tc;

      // ★基準メトリクス決定（両方設定時は、全媒体合計で先に達した側を使う）
      // autoSelect から stoppedBy ('yen'|'copies'|'cps') を渡せる場合はそれを優先。
      if (ty > 0 && tc > 0) {
        const hint = (basisHint === 'yen') ? 'yen'
          : (basisHint === 'cps' || basisHint === 'copies') ? 'cps'
          : null;
        if (hint) {
          GOAL_LOCK.basisMetric = hint;
        } else {
          const tot = getCurrentAllMediaTotals();
          const yenHit = tot.yen >= ty;
          const cpsHit = tot.cps >= tc;
          if (yenHit && !cpsHit) GOAL_LOCK.basisMetric = 'yen';
          else if (cpsHit && !yenHit) GOAL_LOCK.basisMetric = 'cps';
          else if (!yenHit && !cpsHit) {
            // まだどちらにも到達していない場合：到達率が高い方
            const ry = ty > 0 ? (tot.yen / ty) : 0;
            const rc = tc > 0 ? (tot.cps / tc) : 0;
            GOAL_LOCK.basisMetric = (ry >= rc) ? 'yen' : 'cps';
          } else {
            // 両方到達している場合：より「ぎりぎり」側（超過率が小さい方）
            const ry = ty > 0 ? (tot.yen / ty) : 999;
            const rc = tc > 0 ? (tot.cps / tc) : 999;
            GOAL_LOCK.basisMetric = (ry <= rc) ? 'yen' : 'cps';
          }
        }
      } else if (ty > 0) {
        GOAL_LOCK.basisMetric = 'yen';
      } else if (tc > 0) {
        GOAL_LOCK.basisMetric = 'cps';
      } else {
        GOAL_LOCK.basisMetric = null;
      }

      GOAL_LOCK.baseTownOrderAtGoal = Array.isArray(baseSelectOrder) ? baseSelectOrder.slice() : [];
      GOAL_LOCK.selectedAtGoal = new Set(selected);


      if (!mediaCodesAllByName) { clearGoalLock(); return; }

      // 距離（半径）制約は “条件” として適用（距離順では並べない）
      const targetDist = Math.round(toNumber($("distInput")?.value) * 1000);
      const centerForRadius =
        centroidOf(baseCode || "") ??
        lastClickLngLat ??
        getMapCenterLngLat();

      let allowedInRadius = null;
      if (targetDist > 0 && centerForRadius && PRE && PRE.size) {
        allowedInRadius = new Set();
        for (const f of allFeatures) {
          const code = String(f.code);
          const p = PRE.get(code);
          if (!p) continue;
          if (distMeters(centerForRadius, p.centroid) <= targetDist) {
            allowedInRadius.add(code);
          }
        }
      }
      const inRadiusFast = (code) => !allowedInRadius || allowedInRadius.has(String(code));

      // 条件スコア（属性優先のときと同じ）
      const attrKeys = (typeof getSelectedAttributeKeys === 'function') ? getSelectedAttributeKeys() : [];
      const railOn = !!(activeLineStationCentroids && activeLineStationCentroids.length);

      function getAttrStat(code){
        const row = townIndex?.get(String(code));
        if (!row) return { attr: 0, basePop: 0 };
        let attr = 0;
        for (const key of attrKeys) { attr += toNumber(row[key]); }
        const basePop = toNumber(row[POP_TOTAL_KEY] ?? 0);
        return { attr, basePop };
      }

      function townScoreObj(code){
        let score = 0;
        if (attrKeys && attrKeys.length) {
          const { attr, basePop } = getAttrStat(code);
          if (basePop > 0 && attr > 0) score = attr / basePop;
        }
        const railMin = railOn ? (getRailMinDistForTown(String(code)) ?? Infinity) : Infinity;
        return { score, railMin };
      }

      for (const [name] of mediaCodesAllByName.entries()) {
        const m = String(name);

        // ★ 目標到達時点の「その媒体が実際に取れていた分」（prefix）を先頭に置く
        const currentMaxSet = getMaxCodesForMedia(m); // 選択済み ∩ 媒体
        const currentAreas = getMaxAreasForMedia(m, currentMaxSet);
        const orderArr = (mediaAreaOrderByName.get(m) || []).map(String);
        let prefix = orderArr.filter(a => currentAreas.has(a));
        if (!prefix.length && currentAreas && currentAreas.size) {
          const tmp = [];
          const seen = new Set();
          for (const c0 of (GOAL_LOCK.baseTownOrderAtGoal || [])) {
            const code = String(c0);
            if (!currentMaxSet.has(code)) continue;
            const rowsForTown = mediaIndex?.get(code) || [];
            for (const r of rowsForTown) {
              const mm = r["媒体名"] ?? "(名称不明)";
              if (String(mm) !== m) continue;
              const a = getMediaAreaCodeFromRow(r, code);
              if (!currentAreas.has(String(a))) continue;
              if (seen.has(String(a))) continue;
              seen.add(String(a));
              tmp.push(String(a));
            }
          }
          prefix = tmp.length ? tmp : Array.from(currentAreas).map(String);
        }
        const prefixSet = new Set(prefix);

        // ★ B：ロック時の maxSet は “媒体の全域”（＝CSVで取得できた店CD）
        const allCodes = mediaCodesAllByName.get(m) || new Set();
        const universe = new Set();
        for (const c of allCodes) {
          const k = String(c);
          if (inRadiusFast(k)) universe.add(k);
        }
        if (!universe.size) continue;
        GOAL_LOCK.maxSetByMedia.set(m, universe);

        const universeAreas = getMaxAreasForMedia(m, universe);
        if (!universeAreas || !universeAreas.size) continue;

        // === 目標達成後の「追加分」：距離/路線/属性 の“優先度”で店CD(エリア)を並べる ===
        // ポイント：店CDが複数の町にまたがるため、「町順で拾う」と遠隔地が混ざりやすい。
        // そこで、各エリアに紐づく町の「最短距離（& 路線最短）」で近い順に並べ、
        // 自動選択（距離優先）の“増やし方”に近づける。

        const originForOrder =
          centroidOf(baseCode||"") ??
          lastClickLngLat ??
          getMapCenterLngLat();

        // prefix は「目標到達時点で取れていたエリア」：そのまま先頭固定
        const orderedAreas = [];
        const orderedAreaSet = new Set();
        for (const a of prefix) {
          const aa = String(a);
          if (!universeAreas.has(aa)) continue;
          if (orderedAreaSet.has(aa)) continue;
          orderedAreas.push(aa);
          orderedAreaSet.add(aa);
        }

        // 残りエリアをスコアリング（距離優先 / 路線優先 / 属性優先はここで反映）
        const areaMap = getAreaMapAll(m);
        const remainAreas = [];
        for (const a of universeAreas) {
          const aa = String(a);
          if (orderedAreaSet.has(aa)) continue;

          let minDist = Infinity;
          let bestRail = Infinity;
          let bestScore = 0;

          if (areaMap && areaMap.has(aa)) {
            for (const code of areaMap.get(aa)) {
              const k = String(code);
              if (!universe.has(k)) continue;

              // 距離
              const p = PRE?.get(k);
              const cent = p?.centroid || centroidOf(k);
              if (cent && originForOrder) {
                const d = distMeters(originForOrder, cent);
                if (d < minDist) minDist = d;
              }

              // 路線
              if (railOn) {
                const r = getRailMinDistForTown(k);
                const rm = (r == null) ? Infinity : r;
                if (rm < bestRail) bestRail = rm;
              }

              // 属性（属性優先時のみ意味がある）
              if (attrKeys && attrKeys.length) {
                const st = getAttrStat(k);
                if (st.basePop > 0 && st.attr > 0) {
                  const s = st.attr / st.basePop;
                  if (s > bestScore) bestScore = s;
                }
              }
            }
          } else {
            // フォールバック：エリア=町
            const k = aa.startsWith('TOWN:') ? aa.slice(5) : aa;
            if (universe.has(String(k))) {
              const p = PRE?.get(String(k));
              const cent = p?.centroid || centroidOf(String(k));
              if (cent && originForOrder) minDist = distMeters(originForOrder, cent);
              if (railOn) {
                const r = getRailMinDistForTown(String(k));
                bestRail = (r == null) ? Infinity : r;
              }
              if (attrKeys && attrKeys.length) {
                const st = getAttrStat(String(k));
                if (st.basePop > 0 && st.attr > 0) bestScore = st.attr / st.basePop;
              }
            }
          }

          remainAreas.push({ a: aa, minDist, railMin: bestRail, score: bestScore });
        }

        remainAreas.sort((x,y)=>{
          // 路線選択中：駅に近い店CD優先
          if (railOn && x.railMin !== y.railMin) return x.railMin - y.railMin;

          // 属性優先：スコア高い店CD優先（同点は近い順）
          if (attrKeys && attrKeys.length && y.score !== x.score) return y.score - x.score;

          // 距離優先：近い店CD優先（ここが“遠隔地が先に入る”の防止）
          if (x.minDist !== y.minDist) return x.minDist - y.minDist;

          return String(x.a).localeCompare(String(y.a), 'ja');
        });

        for (const o of remainAreas) {
          if (orderedAreaSet.size >= universeAreas.size) break;
          if (orderedAreaSet.has(o.a)) continue;
          orderedAreas.push(o.a);
          orderedAreaSet.add(o.a);
        }

        const ordered = orderedAreas.filter(a => universeAreas.has(String(a)));
        if (!ordered.length) continue;

        // エリアごとの増分（universe 内で計算）
        const gains = ordered.map(a => computeAreaGainForMedia(m, a, universe));

        // “設定がない媒体” 判定（増分がゼロなら不要）
        let sumY = 0, sumC = 0;
        for (const g of gains) { sumY += g.yen; sumC += g.cps; }
        if (!(sumY > 0 || sumC > 0)) continue;

        // 単独達成に必要な店CD数（達成できない場合は取得できた範囲まで）
        let accY = 0, accC = 0;
        let need = gains.length;
        for (let i = 0; i < gains.length; i++) {
          accY += gains[i].yen;
          accC += gains[i].cps;
          // ★両方設定時は、全媒体合計で先に達した側（basisMetric）だけを100%基準にする
          let hit = false;
          if (ty > 0 && tc > 0) {
            hit = (GOAL_LOCK.basisMetric === 'yen') ? (accY >= ty) : (accC >= tc);
          } else {
            hit = ((ty <= 0 || accY >= ty) && (tc <= 0 || accC >= tc));
          }
          if (hit) { need = i + 1; break; }
        }

        const maxCount = Math.max(1, Math.min(need, gains.length));

        // 目標到達時点のゲージ位置（＝その時点で取得できていた prefix 分）に戻す
        const currentCount = prefix.length;
        const initVal = Math.max(0, Math.min(currentCount, maxCount));

        GOAL_LOCK.activeMediaSet.add(m);
        GOAL_LOCK.areaOrderByMedia.set(m, ordered);
        GOAL_LOCK.areaGainByMedia.set(m, gains);
        GOAL_LOCK.maxCountByMedia.set(m, maxCount);
        GOAL_LOCK.valueCountByMedia.set(m, initVal);

        recomputeMediaDisplaySet(m);
        updateSliderUIForMedia(m);
      }
    }

    // ロック中の合計（増分配列の prefix で高速に計算）
    function getCurrentAllMediaTotalsLocked(){
      let yen = 0, cps = 0;
      for (const m of GOAL_LOCK.activeMediaSet) {
        if (!isMediaEnabled(m)) continue;
        const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
        const v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
        for (let i = 0; i < v && i < gains.length; i++) {
          yen += gains[i].yen;
          cps += gains[i].cps;
        }
      }
      return { yen, cps };
    }

    // === ★更新：媒体ごとの「エリアコード単位」で選択順を記憶＆スライダー連動の表示セット ===
    // 基準ビューで町が追加された順（重複なし・再選択時は末尾へ）
    const baseSelectOrder = [];

    // 媒体ごとの「エリアコードが追加された順」（重複なし・再選択時は末尾へ）
    const mediaAreaOrderByName = new Map(); // Map<mediaName, string[]>

    // 媒体ビューで“表示に使う”選択セット（スライダー値に応じてエリア単位で増減した結果）
    const mediaDisplayByName = new Map(); // Map<mediaName, Set<townCode>>

    // ★追加：媒体ビューで“表示に使う”エリア（店CD）集合（スライダー選択の本体）
    const mediaDisplayAreasByName = new Map(); // Map<mediaName, Set<areaCode>>
    function _arrayMoveToEndUnique(arr, value) {
      const v = String(value);
      const i = arr.indexOf(v);
      if (i >= 0) arr.splice(i, 1);
      arr.push(v);
    }

    function _arrayAddUnique(arr, value) {
      const v = String(value);
      if (!arr.includes(v)) arr.push(v); // 既出なら何もしない
    }


    function getMediaAreaCodeFromRow(r, townCode) {
      const s = getStoreCdFromRow(r);
      if (s) return String(s); // 店CD/エリアコードを必ず使う（列名ゆれ対応）
      return `TOWN:${String(townCode)}`;
    }

    function getMediaNamesForTown(code) {
      const rows = mediaIndex?.get(String(code)) || [];
      const set = new Set();
      for (const r of rows) {
        const n = r["媒体名"] ?? "(名称不明)";
        set.add(String(n));
      }
      return [...set];
    }

    function getAreaCodesForTownMedia(code, mediaName) {
      const rows = mediaIndex?.get(String(code)) || [];
      const out = new Set();
      for (const r of rows) {
        const m = r["媒体名"] ?? "(名称不明)";
        if (String(m) !== String(mediaName)) continue;
        out.add(getMediaAreaCodeFromRow(r, code));
      }
      return [...out];
    }

    // 基準の町が追加されたときに順序を記憶（＋媒体別「エリアコード順序」も更新）
    function rememberTownAddedToBase(code) {
      const c = String(code);
      _arrayAddUnique(baseSelectOrder, c);

      // この町に存在する媒体だけ、媒体別の「エリアコード順序」に反映
      const mediaNames = getMediaNamesForTown(c);
      for (const m of mediaNames) {
        const areas = getAreaCodesForTownMedia(c, m);
        let arr = mediaAreaOrderByName.get(m);
        if (!arr) {
          arr = [];
          mediaAreaOrderByName.set(m, arr);
        }
        for (const a of areas) {
          _arrayAddUnique(arr, a);
        }
      }
    }

    // ある媒体・ある町の「部数（未スケール）」
    function getTownCopiesForMedia(code, mediaName) {
      const rows = mediaIndex?.get(String(code)) || [];
      let cps = 0;
      for (const r of rows) {
        const m = r["媒体名"] ?? "(名称不明)";
        if (String(m) !== String(mediaName)) continue;
        cps += toNumber(r["部数"]);
      }
      return cps;
    }

    // この媒体で「最大（=元）」となる選択集合（明示セットがあればそれ、なければ基準選択∩媒体有）
    function getMaxCodesForMedia(mediaName) {
      const explicit = mediaViewByName.get(mediaName);
      // 明示セットが存在するなら（空でも）それを最大セットとする
      if (explicit !== undefined && explicit !== null) return new Set([...explicit].map(String));
      const allCodes = mediaCodesAllByName?.get(mediaName) || new Set();
      const s = new Set();
      for (const c of selected) {
        const k = String(c);
        if (allCodes.has(k)) s.add(k);
      }
      return s;
    }

    function getAreaMapAll(mediaName) {
      return mediaAreaToCodesAllByName?.get(String(mediaName)) || null;
    }

    function getMaxAreasForMedia(mediaName, maxSet) {
      const areaMap = getAreaMapAll(mediaName);
      const out = new Set();
      if (areaMap) {
        for (const [a, codes] of areaMap.entries()) {
          for (const c of codes) {
            if (maxSet.has(String(c))) { out.add(String(a)); break; }
          }
        }
        // ★ エリアコードが実質1つしか無い媒体は、ゲージ増減の粒度が粗すぎて
        //   予算配分（カテゴリ目標）に追従できない。
        //   その場合は町コードを疑似エリア（TOWN:<code>）として扱い、町単位で増減できるようにする。
        if (out.size <= 1 && maxSet && maxSet.size > 1) {
          const townAreas = new Set();
          for (const c of maxSet) townAreas.add(`TOWN:${String(c)}`);
          return townAreas;
        }
        return out;
      }
      // フォールバック：町コードを疑似エリアとして扱う
      for (const c of maxSet) out.add(`TOWN:${String(c)}`);
      return out;
    }

    function getCodesForAreaWithinMax(mediaName, areaCode, maxSet) {
      const a = String(areaCode);
      const out = new Set();
      const areaMap = getAreaMapAll(mediaName);
      if (areaMap && areaMap.has(a)) {
        for (const c of areaMap.get(a)) {
          const k = String(c);
          if (maxSet.has(k)) out.add(k);
        }
        return out;
      }
      // フォールバック：TOWN:<code> 形式
      if (a.startsWith('TOWN:')) {
        const k = a.slice(5);
        if (maxSet.has(k)) out.add(k);
        return out;
      }
      // 最後の手段：そのまま町コードとして扱う
      if (maxSet.has(a)) out.add(a);
      return out;
    }

    
    // ★ 目標ロック用：媒体の「最大集合（universe）」が未生成/空なら、その場で作る（半径制約も反映）
    function ensureGoalLockUniverse(mediaName){
      const m = String(mediaName);
      if (!isGoalLockOn() || !GOAL_LOCK) return null;

      // ★ buildGoalLockFromCurrentSelection では「その時点の選択」に基づく maxSet が入っていることがあるため、
      //   目標ロック中は「媒体の全候補（＋半径制約）」を一度だけ生成してキャッシュする。
      if (!GOAL_LOCK._universeReadyByMedia) GOAL_LOCK._universeReadyByMedia = new Set();

      const cached = GOAL_LOCK.maxSetByMedia?.get(m);
      if (cached && cached.size && GOAL_LOCK._universeReadyByMedia.has(m)) return cached;

      const allCodes = mediaCodesAllByName?.get(m);
      if (!allCodes || !allCodes.size) return null;

      // 距離（半径）制約
      const targetDist = Math.round(toNumber($("distInput")?.value) * 1000);
      const centerForRadius =
        centroidOf(baseCode || "") ??
        lastClickLngLat ??
        getMapCenterLngLat();

      const out = new Set();
      if (targetDist > 0 && centerForRadius) {
        for (const c0 of allCodes) {
          const code = String(c0);
          const p = PRE.get(code);
          if (!p || !p.centroid) continue;
          if (distMeters(centerForRadius, p.centroid) <= targetDist) out.add(code);
        }
      } else {
        for (const c0 of allCodes) out.add(String(c0));
      }

      if (out.size) {
        try {
          GOAL_LOCK.maxSetByMedia.set(m, out);      // ★上書き
          GOAL_LOCK._universeReadyByMedia.add(m);   // ★これ以降はキャッシュを返す
        } catch(e) {}
        return out;
      }
      return null;
    }



    // ★ 目標ロック用：媒体のロック情報（order/gain/maxCount）を未生成なら作る
    function ensureGoalLockMediaPrepared(mediaName){
      const m = String(mediaName);
      if (!isGoalLockOn() || !GOAL_LOCK) return false;

      let uni = ensureGoalLockUniverse(m) || GOAL_LOCK.maxSetByMedia.get(m);
      if (!uni || !uni.size) return false;

      const gains0 = GOAL_LOCK.areaGainByMedia.get(m);
      const order0 = GOAL_LOCK.areaOrderByMedia.get(m);
      const max0 = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
      if (gains0 && gains0.length && order0 && order0.length && max0 > 0) return true;

      const areas = getMaxAreasForMedia(m, uni);
      if (!areas || !areas.size) return false;

      const baseOrder = (mediaAreaOrderByName.get(m) || []);
      const fallbackOrder = (order0 || []);
      const orderArr = (baseOrder.length ? baseOrder : fallbackOrder).map(String);

      let ordered = [];
      if (orderArr.length){
        ordered = orderArr.filter(a => areas.has(String(a))).map(String);
      }
      const setOrd = new Set(ordered);
      for (const a of areas){
        const aa = String(a);
        if (!setOrd.has(aa)) ordered.push(aa);
      }
      if (!ordered.length) return false;

      const gains = ordered.map(a => computeAreaGainForMedia(m, a, uni));

      const ty = Math.round(Number(GOAL_LOCK.targetYen) || 0);
      const tc = Math.round(Number(GOAL_LOCK.targetCopies) || 0);
      let accY = 0, accC = 0;
      let need = gains.length;
      for (let i=0; i<gains.length; i++){
        accY += toNumber(gains[i]?.yen || 0);
        accC += toNumber(gains[i]?.cps || 0);
        let hit = false;
        if (ty > 0 && tc > 0) {
          hit = (GOAL_LOCK.basisMetric === 'yen') ? (accY >= ty) : (accC >= tc);
        } else {
          hit = ((ty <= 0 || accY >= ty) && (tc <= 0 || accC >= tc));
        }
        if (hit) { need = i + 1; break; }
      }
      const maxCount = Math.max(1, Math.min(need, gains.length));

      GOAL_LOCK.maxSetByMedia.set(m, uni);
      GOAL_LOCK.areaOrderByMedia.set(m, ordered);
      GOAL_LOCK.areaGainByMedia.set(m, gains);
      GOAL_LOCK.maxCountByMedia.set(m, maxCount);
      if (!GOAL_LOCK.valueCountByMedia.has(m)) GOAL_LOCK.valueCountByMedia.set(m, 0);
      return true;
    }
// スライダー値に応じて「表示用の選択集合」を作る（店CD/エリアコード単位で増減）
    function recomputeMediaDisplaySet(mediaName) {
      const m = String(mediaName);
      if (!isMediaEnabled(m)) {
        mediaDisplayByName.set(m, new Set());
        mediaDisplayAreasByName.set(m, new Set());
        return;
      }
      let maxSet = getMaxCodesForMedia(m);
      if (isGoalLockOn() && GOAL_LOCK.activeMediaSet.has(m)) {
        const uni = ensureGoalLockUniverse(m) || GOAL_LOCK.maxSetByMedia.get(m);
        if (uni && uni.size) maxSet = uni;
      }
      if (!maxSet.size) {
        mediaDisplayByName.set(m, new Set());
        mediaDisplayAreasByName.set(m, new Set());
        return;
      }

      // 最大セット内に存在する「エリアコード」集合
      const maxAreas = getMaxAreasForMedia(m, maxSet);
      if (!maxAreas.size) {
        mediaDisplayByName.set(m, new Set());
        mediaDisplayAreasByName.set(m, new Set());
        return;
      }

      // エリアの並び（目標ロック中は lock order、それ以外は媒体別順→無ければ基準順から推定）
      const orderArr = mediaAreaOrderByName.get(m) || [];
      let orderedAreas = [];

      if (isGoalLockOn() && GOAL_LOCK.activeMediaSet.has(m)) {
        const lockOrder = GOAL_LOCK.areaOrderByMedia.get(m) || [];
        orderedAreas = lockOrder.map(String).filter(a => maxAreas.has(a));
      } else if (orderArr.length) {
        orderedAreas = orderArr.map(String).filter(a => maxAreas.has(a));
      } else {
        const tmp = [];
        const seen = new Set();
        for (const c0 of baseSelectOrder) {
          const c = String(c0);
          if (!maxSet.has(c)) continue;
          const rows = mediaIndex?.get(c) || [];
          for (const r of rows) {
            const mm = r["媒体名"] ?? "(名称不明)";
            if (String(mm) !== m) continue;
            const a = getMediaAreaCodeFromRow(r, c);
            if (!maxAreas.has(a)) continue;
            if (seen.has(a)) continue;
            seen.add(a);
            tmp.push(a);
          }
        }
        orderedAreas = tmp;
      }

      // 順序配列に無いエリアは末尾に補完
      const setOrdered = new Set(orderedAreas);
      for (const a of maxAreas) {
        if (!setOrdered.has(a)) orderedAreas.push(a);
      }

      // ★ 採用数を決める：通常は％、目標ロック中は「店CD数」
      let keepN = 0;
      if (isGoalLockOn() && GOAL_LOCK.activeMediaSet.has(m)) {
        const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
        const v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
        keepN = Math.max(0, Math.min(v, maxCount));
      } else {
        const scale = getMediaScale(m);
        if (!isFinite(scale) || scale <= 0) {
          mediaDisplayByName.set(m, new Set());
          mediaDisplayAreasByName.set(m, new Set());
          return;
        }
        if (scale >= 0.9999) {
          keepN = orderedAreas.length;
        } else {
          keepN = Math.max(0, Math.round(orderedAreas.length * scale));
        }
      }

      const chosenAreas = orderedAreas.slice(0, keepN);
      mediaDisplayAreasByName.set(m, new Set(chosenAreas.map(String)));
      const out = new Set();
      for (const a of chosenAreas) {
        for (const c of getCodesForAreaWithinMax(m, a, maxSet)) out.add(c);
      }
      mediaDisplayByName.set(m, out);
    }

    function getMediaDisplaySet(mediaName) {
      const m = String(mediaName);
      // ★ townSet / areaSet のどちらかが未生成 or クリアされたら必ず再計算
      if (!mediaDisplayByName.has(m) || !mediaDisplayAreasByName.has(m)) {
        recomputeMediaDisplaySet(m);
      }
      return mediaDisplayByName.get(m) || new Set();
    }

    function getMediaDisplayAreaSet(mediaName) {
      const m = String(mediaName);
      // ★ townSet / areaSet のどちらかが未生成 or クリアされたら必ず再計算
      if (!mediaDisplayByName.has(m) || !mediaDisplayAreasByName.has(m)) {
        recomputeMediaDisplaySet(m);
      }
      return mediaDisplayAreasByName.get(m) || new Set();
    }

    // ★ 店CD（=エリア）単位でのスライダー選択を、行（媒体CSVの1行）に対して判定
    function isRowInMediaDisplay(mediaName, townCode, row) {
      const m = String(mediaName);
      const codeStr = String(townCode);
      const areaSet = getMediaDisplayAreaSet(m);
      if (areaSet && areaSet.size) {
        const a = getMediaAreaCodeFromRow(row, codeStr);
        return areaSet.has(String(a));
      }
      const townSet = getMediaDisplaySet(m);
      return !!(townSet && townSet.size && townSet.has(codeStr));
    }

    // 町の選択追加/解除が起きたときに、関連媒体の表示セットを更新
    function refreshMediaDisplaysForTown(code) {
      const mediaNames = getMediaNamesForTown(String(code));
      for (const m of mediaNames) {
        recomputeMediaDisplaySet(m);
      }
      // 今表示している媒体なら、地図の表示セットも即時更新
      if (viewMode === "media" && currentMediaName) {
        const disp = getMediaDisplaySet(currentMediaName);
        mediaViewSet = new Set(disp);
        applyViewSelection();
      }
    }

// 基準の町（自動選択や手動クリックで使うメインのセット）
    const selected = new Set();

    // ★追加：前回 onLine を付けた町（解除用）
    let prevOnLineTowns = new Set();

    // 媒体ビュー用の「今表示しているセット」
    let mediaViewSet = new Set();

    // 媒体名ごとに、「その媒体で選択している町のセット」を保存しておく
    //   key: 媒体名（文字列）
    //   val: Set<町丁目コード>
    const mediaViewByName = new Map();

    // 今、どの媒体行がアクティブか
    let currentMediaName = null;

    // 表示モード: 'base' = 基準の町, 'media' = 媒体の町
    let viewMode = "base";

    // クリック動作: 'select' = 町を選択, 'center' = 中心点を移動
    let clickMode = "center";

    let geojsonBbox = null;

    // 媒体ビュー用：店cd → 色インデックス（1,2,3...）
    let storeColorIndexByStore = new Map();
    let storeColorIndexMax = 0;

    function getActiveSet() {
      return viewMode === "media" ? mediaViewSet : selected;
    }

    // ★追加：路線選択に合わせて「駅がある町」を強調（onLine=true）
    function applyLineTownHighlight(){
      // map/source がまだなら何もしない
      if (!map || !map.getSource("aichi")) return;

      // あなたが作っている「路線で候補になる町Set」を取得（名前はあなたの実装に合わせて）
      // 例：activeLineTownSet が Set ならそれを使う
      const next = (typeof activeLineTownSet !== "undefined" && activeLineTownSet && activeLineTownSet.size)
        ? activeLineTownSet
        : null;

      // 1) 前回分を解除
      for (const code of prevOnLineTowns){
        map.setFeatureState({ source:"aichi", id:String(code) }, { onLine:false });
      }
      prevOnLineTowns = new Set();

      // 2) 今回分を付与
      if (next) {
        for (const code of next){
          const k = String(code);
          prevOnLineTowns.add(k);
          map.setFeatureState({ source:"aichi", id:k }, { onLine:true });
        }
      }
    }


    function applyViewSelection() {
      if (!map.getSource("aichi")) return;
      const activeSet = getActiveSet();
      const isMedia = (viewMode === "media");

      for (const f of allFeatures) {
        const code = String(f.code);
        const isSel = activeSet.has(code);

        const state = {
          selected: isSel,
          modeMedia: isMedia
        };

        // 基準ビューに戻ったときは storeIdx をクリア
        if (!isMedia) {
          state.storeIdx = 0;
        }

        map.setFeatureState({ source: "aichi", id: code }, state);
      }

      // 媒体ビュー中は店cdごとの色を反映
      if (isMedia) {
        updateStoreColorsForCurrentMedia();
      }

      updateBaseFeatureState();
    }

    // 基準の町＆円
    let baseCode = null, prevBaseCode = null;
    let baseInsideLabel = "";
    function getCenterInsideLabel(){ return baseInsideLabel || ""; }
    const centroidOf = (code)=>{ const f = allFeatures.find(x=>x.code===String(code)); return f?.centroid || null; };
    const bboxOf = (code)=> (bboxCsvByCode.get(String(code)) || featureBboxByCode.get(String(code)) || null);
    const getMapCenterLngLat = ()=>{ const c = map.getCenter(); return [c.lng, c.lat]; };

    function chooseBaseByPoint(lngLat){
      if (!Array.isArray(lngLat)) return;
      let best = null;
      for (const f of allFeatures){
        const d = distMeters(lngLat, f.centroid);
        if (!best || d < best.d) best = { code: String(f.code), d };
      }
      if (best) {
        baseCode = best.code;
        resetFrontierCaches();
        updateBaseFeatureState();
      }
    }
    function ensureBaseIfMissing(){
      if (baseCode) return;
      if (lastClickLngLat){ chooseBaseByPoint(lastClickLngLat); return; }
      if (selected.size){ baseCode = String(Array.from(selected)[0]); updateBaseFeatureState(); return; }
      if (allFeatures.length){ chooseBaseByPoint(getMapCenterLngLat()); }
    }

    // ★ 自動選択開始時：何も選択されていなければ「中心点の町」を1件だけ選ぶ
    function ensureBaseTownSelectedForAuto(targetDistMeters = 0) {
      if (selected.size > 0) return; // 既に何か選んでいれば何もしない

      // 基準町（中心点になる町）を決める
      ensureBaseIfMissing();
      const baseStr = baseCode ? String(baseCode) : null;
      if (!baseStr) return;

      // 距離目標があっても、中心点の町は必ず 0m なのでここでは特に判定不要
      selected.add(baseStr);
      rememberTownAddedToBase(baseStr);
      map.setFeatureState({ source: "aichi", id: baseStr }, { selected: true });

      // 基準町を起点に媒体セットも広げる
      autoExpandMediaFromBaseTown(baseStr);
      refreshMediaDisplaysForTown(baseStr);
    }


    function updateBaseFeatureState(){
      try{
        if (!map.getSource("aichi")) return;

        if (prevBaseCode && prevBaseCode !== baseCode) {
          map.setFeatureState(
            { source: "aichi", id: String(prevBaseCode) },
            { base: false }
          );
        }
        if (baseCode){
          map.setFeatureState(
            { source: "aichi", id: String(baseCode) },
            { base: true }   // ★ selected は触らない
          );
        }
        prevBaseCode = baseCode;
        if (!baseCode) baseInsideLabel = "";

        const pt = centroidOf(baseCode || "");

        // 基準点（中心点）のラベル用名前を作る
        let labelName = "";
        const baseCodeStr = baseCode && String(baseCode);
        if (baseCodeStr && townIndex?.has(baseCodeStr)) {
          const row = townIndex.get(baseCodeStr);
          labelName =
            `${row["市区町村名"] ?? ""} ${row["町丁目名"] ?? ""}`.trim() || baseCodeStr;
          const muni = String(row["市区町村名"] ?? "").trim();
          baseInsideLabel = muni.startsWith("名古屋市") ? "名古屋市内" : "名古屋市外";
        }

        // GeoJSON をセット（name プロパティ付き）
        const baseFeatures = pt
          ? [{
              type: "Feature",
              geometry: { type: "Point", coordinates: pt },
              properties: { name: labelName }
            }]
          : [];

        map.getSource("base-point")?.setData({
          type: "FeatureCollection",
          features: baseFeatures
        });

        // ★ 基準の町が変わったら属性比較も更新
        updateAttrMetrics();
      }catch(e){ console.warn("updateBaseFeatureState skipped:", e); }
    }

    // ★ 媒体ビューでの店cdごとの色付け
    function updateStoreColorsForCurrentMedia() {
      if (!map.getSource("aichi")) return;
      if (!currentMediaName || !mediaIndex) return;

      // インデックスをリセット
      storeColorIndexByStore.clear();
      storeColorIndexMax = 0;

      // まず全ポリゴンの storeIdx を 0 に戻す
      for (const f of allFeatures) {
        map.setFeatureState({ source: "aichi", id: String(f.code) }, { storeIdx: 0 });
      }

      // 媒体ビューで選択されている町（mediaViewSet）だけ、店cdごとに色割当
      for (const code of mediaViewSet) {
        const rowsForTown = mediaIndex.get(String(code));
        if (!rowsForTown) continue;

        // この町 × この媒体 で出ている店cdを抽出
        const stores = [...new Set(
          rowsForTown
            .filter(r => (r["媒体名"] ?? "(名称不明)") === currentMediaName)
            .map(r => getStoreCdFromRow(r))
            .filter(v => v != null && v !== "")
            .map(v => String(v))
        )];

        if (!stores.length) continue;

        // ※ 1町に複数店cdがある場合は、とりあえず1つ目の店cdで色付け
        const store = stores[0];

        if (!storeColorIndexByStore.has(store)) {
          // ★ 1～6 をループさせる
          storeColorIndexMax = (storeColorIndexMax % 6) + 1;
          storeColorIndexByStore.set(store, storeColorIndexMax);
        }
        const idx = storeColorIndexByStore.get(store);

        map.setFeatureState(
          { source: "aichi", id: String(code) },
          { storeIdx: idx }
        );
      }
    }


    function updateViewStatus() {
      const el = $("viewStatus");
      if (!el) return;

      // ★ 選択されている町が1件以上あるか
      const hasSel = getActiveSet().size > 0;

      // ★ 選択があるときだけ付けるクラス
      const activeCls = hasSel ? ' class="is-active"' : '';

      // トグルボタン共通HTML
      const toggleHtml = `
        <button id="clickModeToggleBtn" type="button"
          class="click-mode-toggle ${clickMode === "select" ? "is-select" : "is-center"}">
          <span class="toggle-knob"></span>
          <span class="toggle-text">
            ${clickMode === "select" ? "クリックで町を選択" : "クリックで中心点を移動"}
          </span>
        </button>
      `;

      if (viewMode === "base") {
        el.innerHTML = `
          <span class="view-pill view-pill-base">基準ビュー</span>
          <span>青＝基準の町セット（自動選択対象）</span>
          <div class="view-status-actions">
            <button id="clearBtn" type="button"${activeCls}>全て解除</button>
            <button id="zoomSelBtn" type="button" class="is-active">選択にズーム</button>
            ${toggleHtml}
          </div>
        `;
      } else {
        const nameText = currentMediaName || "（媒体未選択）";
        el.innerHTML = `
          <span class="view-pill view-pill-media">媒体ビュー</span>
          <span>対象媒体：<span class="view-status-name">${escHtml(nameText)}</span></span>
          <div class="view-status-actions">
            <button id="clearBtn" type="button"${activeCls}>全て解除</button>
            <button id="zoomSelBtn" type="button" class="is-active">選択にズーム</button>
            ${toggleHtml}
          </div>
        `;
      }
    }




    

    // ★ 媒体名のゆれ（前後スペース等）を吸収する
    const normMediaName = (v) => {
      const s = String(v ?? "(名称不明)");
      const t = s.trim();
      return t ? t : "(名称不明)";
    };

function isMediaEnabled(name) {
      if (!name) return true;
      return mediaEnabledByName.get(String(name)) !== false;
    }



    // ★ 媒体ごとの部数/料金の倍率（0%〜）
    function getMediaScale(name) {
      const v = mediaScaleByName?.get(String(name));
      const n = Number(v);
      return (Number.isFinite(n) && n >= 0) ? n : 1;
    }
    function setMediaScale(name, scale) {
      const s = Number(scale);
      mediaScaleByName.set(String(name), (Number.isFinite(s) ? Math.max(0, Math.min(1, s)) : 1));
    }


    function renderTargetRadius() {
      const km = toNumber($("distInput").value);
      const r  = Math.round(km * 1000);
      const center =
        (lastClickLngLat ? lastClickLngLat : centroidOf(baseCode || "")) ||
        getMapCenterLngLat();

      const fc = { type: "FeatureCollection", features: [] };

      if (center && r > 0) {
        // 円ポリゴン（線・塗り用）
        const circle = circlePolygon(center, r, 256);
        circle.properties = { kind: "area" };   // ★ ポリゴン側

        // 円周上（いちばん上）の座標をラベル位置にする
        const coords = circle.geometry.coordinates[0] || [];
        let labelCoord = center;
        if (coords.length) {
          labelCoord = coords.reduce(
            (best, cur) => (cur[1] > best[1] ? cur : best),
            coords[0]
          );
        }

        // ラベル用ポイント 1個だけ
        const labelFeature = {
          type: "Feature",
          geometry: { type: "Point", coordinates: labelCoord },
          properties: {
            kind: "label",                             // ★ ラベル用
            label: `半径 ${km.toLocaleString()} km`
          }
        };

        fc.features = [circle, labelFeature];
      }

      map.getSource("target-radius")?.setData(fc);
    }

    let __suppressMediaEnabledRecalc = false;

    function setMediaEnabled(name, enabled) {
      name = String(name);
      mediaEnabledByName.set(name, !!enabled);

      // --- mediaStats テーブル側を更新 ---
      document.querySelectorAll("#mediaStats tr[data-media-name]").forEach(tr => {
        if (tr.getAttribute("data-media-name") !== name) return;

        tr.classList.toggle("media-row-disabled", !enabled);
        const btn = tr.querySelector(".media-toggle");
        if (btn) {
          btn.classList.toggle("off", !enabled);
          btn.textContent = enabled ? "対象" : "除外中";
        }

        const wrap = tr.querySelector(".media-scale-wrap");
        if (wrap) wrap.classList.toggle("disabled", !enabled);
        const slider = tr.querySelector(".media-scale");
        if (slider) slider.disabled = !enabled;
      });

      // --- 属性サマリ側のチェックも同期 ---
      document.querySelectorAll("#attrMetrics .attr-target-check").forEach(cb => {
        if (cb.dataset.mediaName === name) {
          cb.checked = enabled;
        }
      });

      // 再集計・業態指標も更新（※一括変更中は最後にまとめて更新）
      if (!__suppressMediaEnabledRecalc) {
        updateAggregates();
        renderTypeMetrics();

        // ★ 属性比較テーブルも更新（基準の町の部数などを再計算）
        updateAttrMetrics();
      }
    }

    // ★追加：最適組み合わせに絞る（媒体カテゴリ単位で ON/OFF を一括適用）
    
    // ★追加：最適組み合わせに絞る（媒体カテゴリ単位で ON/OFF を一括適用）
    
    // ★全媒体名の一覧（媒体マスタのキー）を取得
    function getAllMediaNames(){
      try {
        return Array.from(mediaCodesAllByName?.keys?.() || []);
      } catch(e) {
        return [];
      }
    }

function applyBestComboToEnabledMedia(bestGroup){
      // 「最適組み合わせに絞る」は、対象外媒体を“対象外（チェックOFF）”にするだけ。
      // 予算配分（0から積み上げ等）はここでは一切しない。
      if (!bestGroup || !bestGroup.cats) return;
      if (!mediaEnabledByName || !mediaCodesAllByName) return;

      const keepCats = new Set((bestGroup.cats || []).map(normalizeTypeCategory).filter(Boolean));

      // 1) チェックON/OFF（対象/除外）だけを一括で切り替える（DOM更新も同期）
      __suppressMediaEnabledRecalc = true;
      try {
        for (const name of mediaCodesAllByName.keys()) {
          const m = String(name);
          const cat = normalizeTypeCategory(mediaCategoryByName.get(m) || "");
          const keep = keepCats.has(cat);
          setMediaEnabled(m, !!keep);
        }
      } finally {
        __suppressMediaEnabledRecalc = false;
      }

      // 2) 目標ロック中：非対象媒体は valueCount=0 にして影響を消す（対象媒体の値は維持）
      //    ※ buildGoalLockFromCurrentSelection() などの“作り直し”はしない（=ゲージが勝手に変わるのを防ぐ）
      if (isGoalLockOn()) {
        const nextActive = new Set();
        for (const m0 of getAllMediaNames()){
          const m = String(m0);
          if (!isMediaEnabled(m)) {
            GOAL_LOCK.valueCountByMedia.set(m, 0);
            continue;
          }
          ensureGoalLockMediaPrepared(m);
          const v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
          const mx = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
          GOAL_LOCK.valueCountByMedia.set(m, Math.min(v, mx));
          nextActive.add(m);
        }
        GOAL_LOCK.activeMediaSet = nextActive;
      }

      // 3) 表示セットを再計算（対象/除外の切替を即反映）
      for (const m0 of getAllMediaNames()){
        const m = String(m0);
        recomputeMediaDisplaySet(m);
        updateSliderUIForMedia(m);
      }

      // 4) 媒体ビュー中なら、表示している媒体のセットを同期（ここをやらないと地図が更新されない）
      syncMediaViewSetIfNeeded();

      // 5) 再描画・再集計（最後にまとめて）
      applyViewSelection();
      updateAggregates();
      updateViewStatus();
      renderTypeMetrics();
      updateAttrMetrics();
      updateAutoButtonHighlight();
    }

    // ★媒体ビューの表示セットを“今の状態”に同期（ボタン操作後の地図更新用）
    function syncMediaViewSetIfNeeded(){
      if (viewMode !== "media") return;

      // 表示中の媒体が除外されていたら、最初の対象媒体に切り替える。無ければ基準ビューへ戻す。
      const isCurrentOk = () => {
        if (!currentMediaName) return false;
        if (!isMediaEnabled(currentMediaName)) return false;
        const p = getSliderParamsForMedia(currentMediaName);
        return !!(p && p.show);
      };

      if (!isCurrentOk()) {
        let found = null;
        for (const m0 of getAllMediaNames()){
          const m = String(m0);
          if (!isMediaEnabled(m)) continue;
          const p = getSliderParamsForMedia(m);
          if (p && p.show) { found = m; break; }
        }
        if (!found) {
          viewMode = "base";
          currentMediaName = null;
          mediaViewSet = new Set();
          return;
        }
        currentMediaName = found;

        // attrMetrics 側のビューラジオもできるだけ同期（存在しなくてもOK）
        document.querySelectorAll("#attrMetrics .attr-view-check").forEach(cb => {
          const kind = cb.dataset.scopeKind || "";
          const mn = cb.dataset.mediaName || "";
          if (kind === "media") cb.checked = (mn === found);
        });
      }

      try {
        recomputeMediaDisplaySet(currentMediaName);
      } catch(e) {}
      mediaViewSet = new Set(getMediaDisplaySet(currentMediaName));
    }


    // ローディングUI（起動時クルクルを「更新中…」にも流用）
const overlay = $("overlay"),
      overlayTitle = $("overlayTitle"),
      overlayMsg = $("overlayMsg"),
      overlayBar = $("overlayBar"),
      overlaySub = $("overlaySub"),
      overlayProgress = overlay?.querySelector(".progress");

function showOverlay(title, msg){
  // init mode（進捗バーあり）
  overlay.dataset.mode = "init";
  if (overlayProgress) overlayProgress.style.display = "block";
  overlay.style.display = "flex";
  overlayTitle.textContent = title || "";
  overlayMsg.textContent   = msg || "";
}
function hideOverlay(){ overlay.style.display="none"; overlay.dataset.mode = ""; }
function setProgress(p, sub=""){
  overlayBar.style.width = `${Math.max(0, Math.min(100, p))}%`;
  overlaySub.textContent = sub;
}

// ★更新時（ゲージ操作/ビュー切替）用：起動時と同じクルクルを流用（進捗バーは非表示）
let __overlayBusyTokenSeq = 0;
let __overlayBusyCurrentToken = 0;
function showOverlayBusy(msg="更新中…"){
  // まだ初期計算中（overlay が init 表示中）のときは邪魔しない
  if (overlay.style.display === "flex" && overlay.dataset.mode === "init") {
    return 0;
  }
  __overlayBusyCurrentToken = ++__overlayBusyTokenSeq;
  overlay.dataset.mode = "busy";
  if (overlayProgress) overlayProgress.style.display = "none";
  overlayBar.style.width = "0%";
  overlaySub.textContent = "";
  overlayTitle.textContent = "更新中…";
  overlayMsg.textContent   = msg;
  overlay.style.display = "flex";
  return __overlayBusyCurrentToken;
}
function hideOverlayBusy(token){
  // token==0 は「初期計算中なので表示しなかった」等
  if (!token) return;
  if (token !== __overlayBusyCurrentToken) return;
  overlay.style.display = "none";
  overlay.dataset.mode  = "";
}
    if (ENABLE_PRECOMPUTE) {
      showOverlay("初期計算を準備中…", "CSVと地図の読み込みを待機中");
    } else {
      hideOverlay();   // UIデバッグ時はすぐ閉じる
    }

    // ★ 駅マスタ読み込み（添付: station_master.csv）
    //   - ヘッダー: line_name, station_name, town_code
    //   - BOM が付いている場合、最初の列が "\ufeffline_name" になるので両対応
    Papa.parse(CSV_STATION, {
      header: true,
      download: true,
      dynamicTyping: false,   // town_code を文字列で保持したいので false
      skipEmptyLines: true,
      encoding: "utf-8",
      complete: (res) => {
        const data = Array.isArray(res.data) ? res.data : [];
        const rows = data.filter(r =>
          r && r["town_code"] != null && String(r["town_code"]).trim() !== ""
        );

        stationRows = rows;
        stationByTown = new Map();
        stationByName = new Map();
        stationByLine = new Map();

        for (const r of rows) {
          const townCode = String(r["town_code"]).trim();
          const lineName = String(r["line_name"] ?? r["\ufeffline_name"] ?? "").trim();
          const stName   = String(r["station_name"] ?? "").trim();

          if (!stationByTown.has(townCode)) stationByTown.set(townCode, []);
          stationByTown.get(townCode).push({ line_name: lineName, station_name: stName });

          if (stName) {
            if (!stationByName.has(stName)) stationByName.set(stName, []);
            stationByName.get(stName).push({ line_name: lineName, town_code: townCode });
          }

          if (lineName) {
            if (!stationByLine.has(lineName)) stationByLine.set(lineName, new Set());
            stationByLine.get(lineName).add(townCode);
          }
        }

        // 町ごとに重複（同一路線・同一駅）を除去
        for (const [code, arr] of stationByTown.entries()) {
          const seen = new Set();
          stationByTown.set(code, arr.filter(o => {
            const key = `${o.line_name}|${o.station_name}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          }));
        }

        // 進捗表示（任意）
        const s = $("summary");
        if (s) s.innerHTML = (s.innerHTML ? (s.innerHTML + " / ") : "") + `<span>CSV(駅)読込完了（${rows.length} 行）</span>`;
        populateLineSelect();
        readyStation = true;
      },
      error: (err) => {
        console.error("CSV_STATION 読み込みエラー", err);
      }
    });



    Papa.parse(CSV_TOWN, {
      header: true, download: true, dynamicTyping: true, encoding: "utf-8",
      complete: (res) => {
        const rows = res.data.filter(r => r && r[CODE_KEY] !== undefined && r[CODE_KEY] !== "");
        townIndex = new Map(rows.map(r => [String(r[CODE_KEY]), r]));
        numericKeys = detectNumericKeys(rows);
        incomeWidthFallback = detectIncomeWidth(numericKeys);

        bboxCsvByCode.clear();
        for (const r of rows){
          const code = String(r[CODE_KEY]);
          const a = Number(r[BBOX_KEYS.minLon]);
          const b = Number(r[BBOX_KEYS.minLat]);
          const c = Number(r[BBOX_KEYS.maxLon]);
          const d = Number(r[BBOX_KEYS.maxLat]);
          if ([a,b,c,d].every(v => Number.isFinite(v))){
            bboxCsvByCode.set(code, [[a,b],[c,d]]);
          }
        }

        $("summary").innerHTML = `<span>CSV(町)</span><span>読込完了（${rows.length} 件 / bbox ${bboxCsvByCode.size} 件）</span>`;
        readyTown = true; tryBuildPrecomputedAsync();
        setupAttributeSelector();
      },
      error: (err) => { $("summary").innerHTML = `<span>CSV(町)エラー</span><span>${err}</span>`; console.error(err); }
    });

    function setupAttributeSelector() {
      const box = $("attributeSelectBox");
      if (!box) return;

      const cols = detectAttributeColumnsFromTownMaster();
      if (!cols.length) {
        box.textContent = "町マスタの数値項目が検出できませんでした。必要に応じて detectAttributeColumnsFromTownMaster() を調整してください。";
        return;
      }

      attributeColumnKeys = cols;

      box.innerHTML = `
        <div>
          重視したい数値項目にチェックを入れてください（複数選択可）。<br>
          例：年齢別人口、年収階級別世帯数など、town_master にある数値列はすべて候補になります。
        </div>
        <div class="attr-listbox">
          ${cols.map(k => `
            <label class="attr-row">
              <input type="checkbox"
                     class="attr-checkbox"
                     data-attr-key="${escHtml(k)}">
              <span class="attr-row-label">${escHtml(k)}</span>
            </label>
          `).join("")}
        </div>
      `;

      // チェック状態が変わったらボタン強調 & 比較表を更新
      box.querySelectorAll(".attr-checkbox").forEach(chk => {
        chk.addEventListener("change", () => {
          updateAutoButtonHighlight();

          updateAttrMetrics();
          updateAttrSummaryLabel();
        });
      });

      // 初期描画
      updateAttrMetrics();
      updateAttrSummaryLabel();
    }



    Papa.parse(CSV_MEDIA, {
      header: true, download: true, dynamicTyping: true, encoding: "utf-8",
      complete: (res) => {
        const rows = res.data.filter(r => r && r[CODE_KEY] !== undefined && r[CODE_KEY] !== "");

        mediaIndex = new Map();
        storeToCodes = new Map();
        mediaCodesAllByName = new Map();   // ★ 全域の媒体 → 町コード
        mediaAreaToCodesAllByName = new Map(); // ★ 全域の媒体 → エリアコード → 町コード

        for (const r of rows) {
          const code  = String(r[CODE_KEY]);
          const store = getStoreCdFromRow(r);
          const name  = normMediaName(r["媒体名"]); r["媒体名"] = name;

          let cat0 = String(r["分類"] ?? "").trim();
          if (cat0 && !mediaCategoryByName.has(name)) mediaCategoryByName.set(name, cat0);

          // 町別 → 媒体行
          if (!mediaIndex.has(code)) mediaIndex.set(code, []);
          mediaIndex.get(code).push(r);

          // 店cd → 町集合
          if (store) {
            if (!storeToCodes.has(store)) storeToCodes.set(store, new Set());
            storeToCodes.get(store).add(code);
          }

          // 媒体名 → 町集合（全域）
          if (!mediaCodesAllByName.has(name)) mediaCodesAllByName.set(name, new Set());
          mediaCodesAllByName.get(name).add(code);

          // ★追加：媒体名 → エリアコード → 町集合（全域）
          const areaCode = getMediaAreaCodeFromRow(r, code);
          if (!mediaAreaToCodesAllByName.has(name)) mediaAreaToCodesAllByName.set(name, new Map());
          const areaMap = mediaAreaToCodesAllByName.get(name);
          if (!areaMap.has(areaCode)) areaMap.set(areaCode, new Set());
          areaMap.get(areaCode).add(code);
        }

        // ★ ここから追加：媒体ごとの ON/OFF を初期化（全部 対象=true）
        mediaEnabledByName = new Map();
        for (const name of mediaCodesAllByName.keys()) {
          mediaEnabledByName.set(name, true);
        }

        // ★追加：媒体ごとの倍率も初期化（全部 100%）
        mediaScaleByName = new Map();
        for (const name of mediaCodesAllByName.keys()) {
          mediaScaleByName.set(name, 1);
        }

        const prev = $("summary").innerHTML;
        $("summary").innerHTML =
          prev.replace("</span></div>", "") +
          ` / <span>CSV(媒体)読込完了（${rows.length} 行）</span></div>`;
        readyMedia = true; tryBuildPrecomputedAsync();
      },
      error: (err) => { /* ここは既存のまま */ }
    });

    // ★ 業態マスタ読み込み（type_master_all.csv：媒体組み合わせ別対応）
    function normalizeTypeCategory(s){
      // ★分類名の揺れ吸収はしない。
      // ただし、type_master_all.csv 側の「媒体」列は「フリーペーパー/ポスティング/折込/web」なので、
      // media_master.csv 側の分類コード（FP/ポス/折込/web）に“厳密に変換”して統一する（contains 等の曖昧処理は一切しない）
      const t = String(s ?? "").trim();
      if (!t) return "";
      if (t === "フリーペーパー") return "FP";
      if (t === "ポスティング") return "ポス";
      if (t === "折込") return "折込";
      if (t.toLowerCase() === "web") return "web";
      // すでにコード側（FP/ポス/折込/web）が入っている場合はそのまま
      return t;
    }
    function normalizeInsideLabel(v){
      const s = String(v ?? "").trim();
      if (!s) return "";
      if (s.includes("市内")) return "名古屋市内";
      if (s.includes("市外")) return "名古屋市外";
      return s;
    }

    function splitMediaList(str){
      return String(str ?? "")
        .split(/[,\u3001]/)
        .map(s => normalizeTypeCategory(String(s).trim()))
        .filter(s => s !== "");
    }
    function makeComboKeyFromArray(arr){
      return Array.from(arr)
        .map(s => normalizeTypeCategory(String(s).trim()))
        .filter(Boolean)
        .sort((a,b)=>a.localeCompare(b,"ja"))
        .join("|");
    }
    function makeComboKeyFromList(listStr){
      return makeComboKeyFromArray(splitMediaList(listStr));
    }

    function getUsedMediaCategories(){
      // 「現在使っている媒体の組み合わせ」は、ゲージ0でも「チェックONなら使っている」とみなす
      //（最適予算配分で 0→積み上げ対象に含めるため）
      const cats = new Set();
      if (!mediaCodesAllByName || !mediaCodesAllByName.size) return cats;
      for (const name of mediaCodesAllByName.keys()){
        if (!isMediaEnabled(name)) continue; // チェックONのみ
        const cat0 = mediaCategoryByName.get(name);
        const cat = normalizeTypeCategory(cat0);
        if (cat) cats.add(cat);
      }
      return cats;
    }


    function getTypeContrib(r){
      const v = (r && (r["貢献度"] ?? r["重み付き貢献度"] ?? r["重み付け貢献度"])) ?? 0;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }
    function getTypeShap(r){
      const v = (r && (r["SHAP"] ?? r["Shapley準拠_接触者平均"])) ?? 0;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    function pickTypeRowsForCurrentCombo(gyotai){
      const gy = String(gyotai || "");
      const comboMap = typeMasterByGyotaiCombo.get(gy);
      const allRows = typeMasterByGyotai.get(gy) || [];
      if (!comboMap || comboMap.size === 0) {
        return { rows: allRows, comboKey: null, match: "gyotai-only" };
      }

      const usedCats = Array.from(getUsedMediaCategories());
      const usedKey  = makeComboKeyFromArray(usedCats);

      const desiredInside = getCenterInsideLabel(); // "名古屋市内" / "名古屋市外" / ""
      const keyFull = (desiredInside ? (desiredInside + "||" + usedKey) : ("||" + usedKey));

      if (comboMap.has(keyFull)) {
        const g = comboMap.get(keyFull);
        return { rows: g.rows, comboKey: keyFull, match: "exact", meta: g.meta };
      }

      const desiredHas = !!desiredInside;
      const candidates = [];
      for (const g of comboMap.values()){
        const ins = normalizeInsideLabel(g?.meta?.inside ?? "");
        if (desiredHas && ins && ins !== desiredInside) continue;
        candidates.push(g);
      }
      const pool = candidates.length ? candidates : Array.from(comboMap.values());

      // best subset fallback（使っている媒体の部分集合で、最大媒体数のもの）
      const usedSet = new Set(usedCats.map(normalizeTypeCategory));
      let best = null;
      let bestSize = -1;
      for (const g of pool){
        const s = new Set((g.cats || []).map(normalizeTypeCategory));
        let ok = true;
        for (const c of s){
          if (!usedSet.has(c)) { ok = false; break; }
        }
        if (!ok) continue;
        if (s.size > bestSize){
          best = g; bestSize = s.size;
        }
      }
      if (best) {
        return { rows: best.rows, comboKey: best.key, match: "subset", meta: best.meta };
      }

      // fallback: pick the closest (Jaccard)
      let best2 = null;
      let bestScore = -1;
      for (const g of pool){
        const s = new Set((g.cats || []).map(normalizeTypeCategory));
        let inter = 0;
        for (const c of s) if (usedSet.has(c)) inter++;
        const union = new Set([...s, ...usedSet]).size || 1;
        const score = inter / union;
        if (score > bestScore){
          bestScore = score; best2 = g;
        }
      }
      if (best2) return { rows: best2.rows, comboKey: best2.key, match: "closest", meta: best2.meta };

      return { rows: allRows, comboKey: null, match: "gyotai-only" };
    }

    // ===== 「最適組み合わせに絞る」用：任意 combo グループの業態指標を計算 =====
    // 既存 computeGyotaiMetrics と同じ考え方で、rows(=type_master_all の媒体行) から cap を作り、
    // 現在の選択町（媒体ビュー union ∩ 基準選択町）に対して推測視認率/来店期待値を算出する。
    function computeGyotaiMetricsForComboGroup(group){
      if (!group || !group.rows || !group.rows.length) {
        return { viewRate: null, visitRaw: null };
      }
      if (!mediaIndex || !townIndex) {
        return { viewRate: null, visitRaw: null };
      }

      const rows = group.rows;
      const baseStr = baseCode ? String(baseCode) : null;

      // この組み合わせの媒体カテゴリ集合（type_master_all の「媒体」列）
      const categories = new Set(
        rows
          .map(r => normalizeTypeCategory(String(r["媒体"] ?? "").trim()))
          .filter(Boolean)
      );
      if (!categories.size) return { viewRate: null, visitRaw: null };

      // cap を準備（貢献度の絶対値を 0.3〜1.0 にマップ）
      let maxAbsContrib = 0;
      for (const r of rows) {
        const contrib = getTypeContrib(r);
        if (!Number.isFinite(contrib)) continue;
        const abs = Math.abs(contrib);
        if (abs > maxAbsContrib) maxAbsContrib = abs;
      }
      const denom = maxAbsContrib || 1;

      const mediaCap = new Map();
      for (const r of rows) {
        const cat = normalizeTypeCategory(String(r["媒体"] ?? "").trim());
        if (!cat) continue;
        const contrib = getTypeContrib(r);
        const abs = Math.max(0, Math.abs(contrib));
        const normalized = abs / denom;          // 0〜1
        const cap = 0.3 + 0.7 * normalized;      // 0.3〜1.0
        const prev = mediaCap.get(cat);
        mediaCap.set(cat, prev != null ? Math.max(prev, cap) : cap);
      }

      // ① 媒体ビュー union（ただし、この組み合わせの媒体カテゴリだけ）
      const allMediaSelected = new Set();
      if (mediaViewByName && typeof mediaViewByName.entries === "function") {
        for (const [mediaName, set] of mediaViewByName.entries()) {
          if (!set || !set.size) continue;
          if (!isMediaEnabled(mediaName)) continue;
          const cat0 = normalizeTypeCategory(mediaCategoryByName.get(mediaName) || "");
          if (!categories.has(cat0)) continue;
          for (const c of set) allMediaSelected.add(String(c));
        }
      }

      // ② union ∩ 基準選択町（※基準町除外）
      let targetCodes = [];
      if (allMediaSelected.size) {
        for (const c of allMediaSelected) {
          const s = String(c);
          if (baseStr && s === baseStr) continue;
          if (!selected.has(s)) continue;
          targetCodes.push(s);
        }
      }
      if (!targetCodes.length) {
        targetCodes = Array.from(selected).filter(code => {
          const s = String(code);
          return !baseStr || s !== baseStr;
        });
      }
      if (!targetCodes.length) return { viewRate: null, visitRaw: null };

      const center =
        lastClickLngLat ||
        centroidOf(baseCode || "") ||
        getMapCenterLngLat();

      let hhSum = 0;
      let seenSum = 0;
      let visitRaw = 0;

      for (const code of targetCodes) {
        const codeStr = String(code);
        const townRow = townIndex.get(codeStr);
        if (!townRow) continue;
        const hh = toNumber(townRow[HH_TOTAL_KEY] ?? 0);
        if (!hh) continue;

        const mediaRows = mediaIndex.get(codeStr);
        if (!mediaRows) continue;

        let notSeenProd = 1;
        let hasAny = false;

        for (const r of mediaRows) {
          const cat = normalizeTypeCategory(String(r["分類"] ?? "").trim());
          if (!categories.has(cat)) continue;
          const mediaName = r["媒体名"] ?? "(名称不明)";
          if (!isMediaEnabled(mediaName)) continue;
          if (!isRowInMediaDisplay(mediaName, codeStr, r)) continue;

          const copies = toNumber(r["部数"]);
          if (!copies) continue;

          const cap = mediaCap.get(cat) ?? 0.6;
          const baseCov = Math.min(1, copies / hh);
          let cov = baseCov * cap;
          if (cov <= 0) continue;
          if (cov > 1) cov = 1;

          hasAny = true;
          notSeenProd *= (1 - cov);
        }

        if (!hasAny) continue;
        const coverageTown = 1 - notSeenProd;
        hhSum += hh;
        seenSum += hh * coverageTown;

        const p = PRE.get(codeStr);
        const centroid = p?.centroid || centroidOf(codeStr);
        if (centroid && center) {
          const dKm = distMeters(center, centroid) / 1000;
          const decay = 1 / (1 + dKm);
          visitRaw += hh * coverageTown * decay;
        }
      }

      const viewRate = hhSum > 0 ? (seenSum / hhSum) : null;
      return { viewRate, visitRaw: visitRaw || null };
    }

    function pickBestComboGroupForCurrentUsage(gyotai){
  const gy = String(gyotai || "");
  const comboMap = typeMasterByGyotaiCombo.get(gy);
  if (!comboMap || !comboMap.size) return null;

  // 現在「使用中」とみなす媒体カテゴリ（ON かつ表示セットが1件以上ある媒体）
  const usedCats = Array.from(getUsedMediaCategories()).map(normalizeTypeCategory).filter(Boolean);
  const usedSet  = new Set(usedCats);
  if (!usedSet.size) return null;

  const desiredInside = getCenterInsideLabel();

  const candidates = [];
  for (const g of comboMap.values()) {
    const ins = normalizeInsideLabel(g?.meta?.inside ?? "");
    if (desiredInside && ins && ins !== desiredInside) continue;

    const cats = (g.cats || []).map(normalizeTypeCategory).filter(Boolean);
    if (!cats.length) continue;

    // 「今使ってる媒体カテゴリ」の部分集合のみを候補（未使用カテゴリを含む組み合わせは除外）
    let ok = true;
    for (const c of cats) { if (!usedSet.has(c)) { ok = false; break; } }
    if (!ok) continue;

    candidates.push(g);
  }
  if (!candidates.length) return null;

  // ★評価は CSV の「重み付き貢献度」合計で行う（ここが reach 的な単調増加だと“全媒体が常に最適”になりがち）
  let best = null;
  let bestTotal = -Infinity;
  let bestPos   = -Infinity;
  let bestSize  = Infinity; // 同点なら少ない媒体数を優先（運用しやすい）
  for (const g of candidates) {
    const rows = g.rows || [];
    let total = 0;
    let pos = 0;
    for (const r of rows) {
      const w = toNumber(r["重み付き貢献度"]);
      if (!Number.isFinite(w)) continue;
      total += w;
      if (w > 0) pos += w;
    }
    const sz = (g.cats || []).length;

    if (
      (total > bestTotal) ||
      (total === bestTotal && pos > bestPos) ||
      (total === bestTotal && pos === bestPos && sz < bestSize)
    ) {
      best = g;
      bestTotal = total;
      bestPos = pos;
      bestSize = sz;
      best._csvScore = { totalWeighted: total, positiveWeighted: pos };
    }
  }
  return best;
}

    async function loadTypeMaster(){
      try{
        const resp = await fetch(CSV_TYPE, {cache:"no-store"});
        const buf = await resp.arrayBuffer();
        let csvText = "";
        try { csvText = new TextDecoder("shift-jis").decode(buf); }
        catch (e) { csvText = new TextDecoder("utf-8").decode(buf); }

        const parsed = Papa.parse(csvText, {header:true, dynamicTyping:true, skipEmptyLines:true});
        const rows = (parsed.data || []).filter(r => r && r["業態"]);

        typeMasterRows = rows;

        // gyotai / combo で索引化
        typeMasterByGyotai.clear();
        typeMasterByGyotaiCombo.clear();

        for (const r of rows) {
          const g = String(r["業態"]);
          if (!typeMasterByGyotai.has(g)) typeMasterByGyotai.set(g, []);
          typeMasterByGyotai.get(g).push(r);

          const listStr = String(r["採用媒体一覧"] ?? "").trim();
          const comboKey = makeComboKeyFromList(listStr);
          const inside = normalizeInsideLabel(r["市内外"] ?? "");
          const key = (inside ? (inside + "||" + comboKey) : ("||" + comboKey));

          if (!typeMasterByGyotaiCombo.has(g)) typeMasterByGyotaiCombo.set(g, new Map());
          const m = typeMasterByGyotaiCombo.get(g);

          if (!m.has(key)) {
            m.set(key, {
              key,
              cats: splitMediaList(listStr),
              meta: {
                listStr,
                comboId: r["組み合わせID"] ?? "",
                comboName: r["組み合わせ名"] ?? "",
                file: r["ファイル名"] ?? "",
                inside: inside
              },
              rows: []
            });
          }
          m.get(key).rows.push(r);
        }

        // コンボボックスへ業態一覧を流し込む
        const sel = $("typeSelect");
        if (sel) {
          const gyotaiList = Array.from(typeMasterByGyotai.keys())
            .sort((a,b)=>a.localeCompare(b,"ja"));
          sel.innerHTML =
            `<option value="">業態を選択...</option>` +
            gyotaiList.map(g => `<option value="${escHtml(g)}">${escHtml(g)}</option>`).join("");
        }

        renderTypeMetrics();
      } catch (err) {
        console.error("CSV_TYPE 読み込みエラー", err);
        const box = $("typeList");
        if (box) box.textContent = "業態マスタの読み込みに失敗しました。";
      }
    }
    loadTypeMaster();


    map.on("load", async () => {
      const res = await fetch(GEOJSON_URL);
      if (!res.ok) { $("summary").innerHTML = `<span>GeoJSON</span><span>読み込み失敗 (${res.status})</span>`; return; }
      const gj = await res.json();

      (function bbox(g) {
        let minx= 1e9, miny= 1e9, maxx=-1e9, maxy=-1e9;
        for (const f of g.features) {
          const t = f.geometry?.type;
          const cs = f.geometry?.coordinates || [];
          const bump = (x,y)=>{ if(x<minx)minx=x; if(y<miny)miny=y; if(x>maxx)maxx=x; if(y>maxy)maxy=y; };
          if (t==="Polygon")  for (const r of cs) for (const [x,y] of r) bump(x,y);
          if (t==="MultiPolygon") for (const p of cs) for (const r of p) for (const [x,y] of r) bump(x,y);
        }
        geojsonBbox = [[minx,miny],[maxx,maxy]];
      })(gj);

      map.addSource("aichi", { type: "geojson", data: gj, promoteId: CODE_KEY });

      allFeatures = gj.features.map(f => {
        const code = String(f.properties?.[CODE_KEY] ?? "");
        let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
        const t = f.geometry?.type, cs = f.geometry?.coordinates || [];
        const bump=(x,y)=>{ if(x<minx)minx=x; if(y<miny)miny=y; if(x>maxx)maxx=x; if(y>maxy)maxy=y; };
        if (t==="Polygon")      for (const r of cs) for (const [x,y] of r) bump(x,y);
        else if (t==="MultiPolygon") for (const p of cs) for (const r of p) for (const [x,y] of r) bump(x,y);
        const centroid=[(minx+maxx)/2,(miny+maxy)/2];
        featureBboxByCode.set(code, [[minx,miny],[maxx,maxy]]);
        return { code, centroid };
      });

      // ターゲット円
      map.addSource("target-radius", { type:"geojson", data:{ type:"FeatureCollection", features:[] } });
      map.addLayer({ id:"target-radius-halo", type:"line", source:"target-radius",
        paint:{ "line-color":"#ef4444", "line-width":8, "line-blur":4, "line-opacity":0.45 } }, "osm");
      map.addLayer({ id:"target-radius-line", type:"line", source:"target-radius",
        paint:{ "line-color":"#dc2626", "line-width":3.5, "line-dasharray":[2,2], "line-opacity":0.95 }});
      map.addLayer({ id:"target-radius-fill", type:"fill", source:"target-radius",
        paint:{ "fill-color":"#fecaca", "fill-opacity":0.28 }});
      map.addLayer({
        id: "target-radius-label",
        type: "symbol",
        source: "target-radius",
        filter: ["==", ["get", "kind"], "label"],   // ★ ラベル用ポイントだけ
        layout: {
          "text-field": ["get", "label"],
          "text-size": 14,
          "text-anchor": "center",
          "text-allow-overlap": false
        },
        paint: {
          "text-color": "#991b1b",
          "text-halo-color": "#ffffff",
          "text-halo-width": 2
        }
      });

      // 基準点
      map.addSource("base-point", { type:"geojson", data:{ type:"FeatureCollection", features:[] } });
      map.addLayer({ id:"base-point-circle", type:"circle", source:"base-point",
        paint:{ "circle-radius":6, "circle-color":"#ea580c", "circle-stroke-color":"#fff", "circle-stroke-width":2 }});

      map.addLayer({
        id: "base-point-label",
        type: "symbol",
        source: "base-point",
        layout: {
          "text-field": ["get", "name"],
          "text-size": 14,
          "text-anchor": "top",
          "text-offset": [0, 1.2]   // 点の少し上に表示
        },
        paint: {
          "text-color": "#111827",
          "text-halo-color": "#ffffff",
          "text-halo-width": 2
        }
      });

      // 町ポリゴン      
      map.addLayer({ id:"aichi-fill", type:"fill", source:"aichi",
        paint:{
          "fill-color":[
            "case",
            // 基準の町（オレンジ優先）
            ["boolean",["feature-state","base"],false], "#fb923c",

            // ★ 媒体ビュー && storeIdx>0 → 店cd色（1～6をループ）
            ["all",
              ["boolean",["feature-state","modeMedia"],false],
              [">", ["feature-state","storeIdx"], 0]
            ],
            [
              "case",
                ["==", ["feature-state","storeIdx"], 1], "#0ea5e9",  // 1
                ["==", ["feature-state","storeIdx"], 2], "#22c55e",  // 2
                ["==", ["feature-state","storeIdx"], 3], "#eab308",  // 3
                ["==", ["feature-state","storeIdx"], 4], "#f97316",  // 4
                ["==", ["feature-state","storeIdx"], 5], "#a855f7",  // 5
                ["==", ["feature-state","storeIdx"], 6], "#ec4899",  // 6
                /* 念のためデフォルト */
                "#3b82f6"
            ],

            // 通常の selected（基準ビューや媒体ビューで色が決まらない場合）
            ["boolean",["feature-state","selected"],false], "#3b82f6",

            // hover
            ["boolean",["feature-state","hover"],false],    "#60a5fa",

            // ★ 路線選択で強調（駅の町）
            ["boolean",["feature-state","onLine"],false], "#fde047",

            // それ以外は透明
            "#00000000"
          ],
          "fill-opacity":[
            "case",
              ["boolean",["feature-state","base"],false], 0.35,
              ["boolean",["feature-state","selected"],false], 0.55,
              ["boolean",["feature-state","hover"],false],    0.35,
              // ★追加：路線強調の表示
              ["boolean",["feature-state","onLine"],false],   0.22,
              0.0
          ]
        }});

        // 町境界線（うるささ対策つき）
        map.addLayer({
          id: "aichi-line",
          type: "line",
          source: "aichi",
          paint: {
            "line-color": ["case",
              ["boolean", ["feature-state", "base"], false], "#b45309",
              ["boolean", ["feature-state", "selected"], false], "#1e40af",
              ["boolean", ["feature-state", "onLine"], false], "#eab308",
              "#1e3a8a"
            ],
            "line-width": ["case",
              ["boolean", ["feature-state", "base"], false], 2.6,
              ["boolean", ["feature-state", "selected"], false], 1.8,
              ["boolean", ["feature-state", "onLine"], false], 2.2,
              0.6
            ],

            // 通常の町境界線はズームするまで薄く/非表示、基準・選択・路線強調は常に見せる
            "line-opacity": [
              "interpolate", ["linear"], ["zoom"],
                0, ["case",
                      ["any",
                        ["boolean", ["feature-state", "base"], false],
                        ["boolean", ["feature-state", "selected"], false],
                        ["boolean", ["feature-state", "onLine"], false]
                      ],
                      1, 0
                   ],
                10.8, ["case",
                      ["any",
                        ["boolean", ["feature-state", "base"], false],
                        ["boolean", ["feature-state", "selected"], false],
                        ["boolean", ["feature-state", "onLine"], false]
                      ],
                      1, 0
                   ],
                11.2, ["case",
                      ["any",
                        ["boolean", ["feature-state", "base"], false],
                        ["boolean", ["feature-state", "selected"], false],
                        ["boolean", ["feature-state", "onLine"], false]
                      ],
                      1, 0.7
                   ]
            ]
          }
        });

        // ★ 中心点と距離圏の円を最前面に出す
        [
          "target-radius-fill",
          "target-radius-halo",
          "target-radius-line",
          "base-point-circle",
          "base-point-label",
          "target-radius-label"
        ].forEach(id => {
          if (map.getLayer(id)) map.moveLayer(id);
        });



      let hovered=null;
      map.on("mousemove","aichi-fill",(e)=>{ const f=e.features?.[0]; if(!f) return;
        const id=f.id ?? f.properties?.[CODE_KEY];
        if(hovered && hovered!==id) map.setFeatureState({source:"aichi",id:hovered},{hover:false});
        hovered=id; map.setFeatureState({source:"aichi",id:hovered},{hover:true});
      });
      map.on("mouseleave","aichi-fill",()=>{ if(hovered) map.setFeatureState({source:"aichi",id:hovered},{hover:false}); hovered=null; });

      map.on("click", "aichi-fill", (e) => {
        const f = e.features?.[0];
        if (!f) return;

        const code = String(f.properties?.[CODE_KEY] ?? "");
        if (!code) return;

        // --- 基準ビューのクリック ---
        if (viewMode === "base") {

          // クリックで「町を選択」モード
          if (clickMode === "select") {
            if (selected.has(code)) {
              // 解除時はとりあえず何もしない（媒体側は自動では消さない）
              selected.delete(code);
              map.setFeatureState({ source: "aichi", id: code }, { selected: false });
              refreshMediaDisplaysForTown(code);
            } else {
              // ★ 新たに基準町を追加
              selected.add(code);
              rememberTownAddedToBase(code);
              map.setFeatureState({ source: "aichi", id: code }, { selected: true });

              // ★ 追加された町を起点に、媒体ごとの「店cd展開セット」を更新
              autoExpandMediaFromBaseTown(code);
              refreshMediaDisplaysForTown(code);
            }

            // 基準点は動かさない
            updateAggregates();
            updateViewStatus();
            updateAttrMetrics();
            return;
          }

          // クリックで「中心点を移動」モード
          if (clickMode === "center") {
            lastClickLngLat = [e.lngLat.lng, e.lngLat.lat];
            baseCode = code;
            resetFrontierCaches();
            updateBaseFeatureState();
            renderTargetRadius();
            return;
          }
        }

        // --- 媒体ビューのクリック：同じ店cdの町をまとめてON/OFF ---
        if (viewMode === "media" && currentMediaName) {
          const codeStr = String(code);

          // この媒体用のセットを取得（なければ現在ビューから作る）
          let set = mediaViewByName.get(currentMediaName);
          if (!set) {
            set = new Set(mediaViewSet);
            mediaViewByName.set(currentMediaName, set);
          }

          // この町 × 現在の媒体 で出ている店cdを取得（複数あっても先頭だけ採用）
          const rowsForTown = mediaIndex?.get(codeStr) || [];
          const stores = [...new Set(
            rowsForTown
              .filter(r => (r["媒体名"] ?? "(名称不明)") === currentMediaName)
              .map(r => getStoreCdFromRow(r))
              .filter(v => v != null && v !== "")
              .map(v => String(v))
          )];

          const store = stores[0];
          if (!store) {
            // 店cd が取れない場合は何もしない
            updateAggregates();
            return;
          }

          // この店cdが出ている町リスト（storeToCodes は店cd→町集合）
          const codesForStore = storeToCodes.get(store) || new Set();

          // 「この媒体」でも同じ店cdが出ている町だけに絞り込む
          const targetCodes = [];
          codesForStore.forEach(c => {
            const cStr = String(c);
            const rows = mediaIndex.get(cStr);
            if (!rows) return;

            // 店cd & 媒体名が一致する行があれば対象
            const hit = rows.some(r =>
              String(getStoreCdFromRow(r) ?? "") === store &&
              (r["媒体名"] ?? "(名称不明)") === currentMediaName
            );
            if (hit) targetCodes.push(cStr);
          });

          if (!targetCodes.length) {
            updateAggregates();
            return;
          }

          // クリックした町が選択状態かどうかで、ON/OFF を決める
          const clickedSelected = set.has(codeStr);

          if (clickedSelected) {
            // ★ 選択状態 → 同じ店cdの町を全部 OFF
            for (const c of targetCodes) {
              set.delete(c);
              mediaViewSet.delete(c);
              map.setFeatureState({ source: "aichi", id: c }, { selected: false, storeIdx: 0 });
            }
          } else {
            // ★ 未選択状態 → 同じ店cdの町を全部 ON
            for (const c of targetCodes) {
              set.add(c);
              mediaViewSet.add(c);
              map.setFeatureState({ source: "aichi", id: c }, { selected: true });
            }
          }

          // 店cdごとの色も更新
          updateStoreColorsForCurrentMedia();

          // ★ スライダー倍率に応じた表示範囲に整形（表示セットを優先）
          recomputeMediaDisplaySet(currentMediaName);
          mediaViewSet = new Set(getMediaDisplaySet(currentMediaName));
          applyViewSelection();

          // 基準ビューには触らない
          updateAggregates();
          updateViewStatus(); 
          updateAttrMetrics();
          return;
        }
      });



      map.on("click",(e)=>{ // 背景クリックでも基準更新（※媒体ビュー中 or 選択モード中は動かさない）
        if (viewMode === "media" || clickMode === "select") {
          // 媒体ビュー中 or 「町を選択」モード中は中心点を動かさない
          return;
        }

        lastClickLngLat = [e.lngLat.lng, e.lngLat.lat];
        chooseBaseByPoint(lastClickLngLat);
        renderTargetRadius();
      });

      // 「全て解除」「選択にズーム」などは viewStatus 内に動的に描画するので
      // ドキュメント全体に対してイベント委譲で処理する
      document.addEventListener("click", (ev) => {
        const t = ev.target;
        if (!(t instanceof HTMLElement)) return;

        if (t.id === "clearBtn") {
          ev.preventDefault();

          const allCodes = new Set([...selected, ...mediaViewSet]);
          for (const code of allCodes) {
            map.setFeatureState({ source: "aichi", id: code }, { selected: false });
          }
          selected.clear();
          mediaViewSet.clear();
          mediaViewByName.clear();
          baseSelectOrder.length = 0;
          mediaAreaOrderByName.clear();
          mediaDisplayByName.clear();
          mediaDisplayAreasByName.clear();
          viewMode = "base";
          currentMediaName = null;
          resetFrontierCaches();
          updateAggregates();
          updateViewStatus();
          if (IS_AUTO_RUNNING) setStopEnabled(true); else resetStop();

          // 目標入力強調もリセット
          updateAutoButtonHighlight();
          // ★最適ボタン強調も「全て解除」でリセット
          clearOptimizeButtonEmph();

        } else if (t.id === "zoomSelBtn") {
          ev.preventDefault();

          const currentSet = getActiveSet();

          // ★ 町が未選択のときは「中心点（基準の町）」にズーム
          if (!currentSet.size) {
            // 中心点の取り方は、ターゲット円と同じロジックを流用
            const center =
              (lastClickLngLat ? lastClickLngLat : centroidOf(baseCode || "")) || getMapCenterLngLat();

            if (center) {
              map.flyTo({
                center,
                zoom: 14,      // 好きなズームレベルに調整してOK
                duration: 500,
              });
            }
            return;
          }

          // ★ 1件以上選択されているときは、今まで通り「選択範囲」にズーム
          let minx = 1e9, miny = 1e9, maxx = -1e9, maxy = -1e9;
          for (const c of currentSet) {
            const b = bboxOf(c);
            if (!b) continue;
            const [[x1, y1], [x2, y2]] = b;
            if (x1 < minx) minx = x1;
            if (y1 < miny) miny = y1;
            if (x2 > maxx) maxx = x2;
            if (y2 > maxy) maxy = y2;
          }
          if (minx < maxx && miny < maxy) {
            map.fitBounds([[minx, miny], [maxx, maxy]], { padding: 40, duration: 500 });
          }


        // ▼ ここを追加 ▼
        } else if (t.id === "clickModeToggleBtn" || t.closest?.("#clickModeToggleBtn")) {
          ev.preventDefault();
          // モードをトグル
          clickMode = (clickMode === "select") ? "center" : "select";
          // ボタンの表示を更新
          updateViewStatus();
        }
      });



      if (geojsonBbox) map.fitBounds(geojsonBbox, { padding: 40, duration: 700 });
      readyGeo = true; tryBuildPrecomputedAsync();
    });

    // フォーマッタ適用
    setupSmartFormatter("budgetInput",      "万円");
    setupSmartFormatter("copiesInput",      "万部");
    setupSmartFormatter("distInput",        "km",   { onCommit: () => renderTargetRadius() });
    setupSmartFormatter("targetAge",        "歳");
    setupSmartFormatter("targetAgeMale",    "歳");
    setupSmartFormatter("targetAgeFemale",  "歳");
    setupSmartFormatter("targetIncome",     "万円");

    // ★ 目標入力欄の変化で自動選択ボタンの強調を更新
    ["budgetInput","copiesInput","distInput",
     "targetAge","targetAgeMale","targetAgeFemale","targetIncome"
    ].forEach(id => {
      const el = $(id);
      if (!el) return;
      ["input","change","blur"].forEach(ev =>
        el.addEventListener(ev, updateAutoButtonHighlight)
      );
    });

    // 初期状態
    updateAutoButtonHighlight();


    // 事前計算
    let PRE = new Map();
    let neighborCache = new Map();
    let neighborPtr   = new Map();

    // 対象ONの媒体だけの料金・部数を合計（1町分）
    function getEnabledMediaTotalsForTown(code) {
      const key = String(code);
      if (!mediaIndex) return { yen: 0, cps: 0 };

      const rowsForTown = mediaIndex.get(key);
      if (!rowsForTown) return { yen: 0, cps: 0 };

      let yen = 0;
      let cps = 0;
      for (const r of rowsForTown) {
        const mName = r["媒体名"] ?? "(名称不明)";
        if (!isMediaEnabled(mName)) continue;  // 対象ONのみ

        // 媒体ビューで明示セットがある場合（空でも）それを優先
        const explicit = mediaViewByName?.get(mName);
        if (explicit !== undefined && explicit !== null && !explicit.has(key)) continue;

        // ★ 店CD（=エリア）単位のスライダー選択を反映
        if (!isRowInMediaDisplay(mName, key, r)) continue;

        yen += toNumber(r["料金"]);
        cps += toNumber(r["部数"]);
      }
      return { yen, cps };
    }

    // ★ 現在の「全媒体対象（対象ONのみ）」の料金・部数合計
    function getCurrentAllMediaTotals() {
      if (!mediaIndex || !mediaCodesAllByName) return { yen: 0, cps: 0 };

      let yen = 0;
      let cps = 0;

      // 媒体ごとに「スライダー反映後（店CD/エリア単位）」の表示セットで集計
      for (const [name] of mediaCodesAllByName.entries()) {
        if (!isMediaEnabled(name)) continue;

        const dispSet = getMediaDisplaySet(name);
        const areaSet = getMediaDisplayAreaSet(name);
        if (!dispSet || !dispSet.size || !areaSet || !areaSet.size) continue;

        for (const code0 of dispSet) {
          const code = String(code0);
          const rowsForTown = mediaIndex.get(code);
          if (!rowsForTown) continue;
          for (const r of rowsForTown) {
            const mName = r["媒体名"] ?? "(名称不明)";
            if (String(mName) !== String(name)) continue;
            const a = getMediaAreaCodeFromRow(r, code);
            if (!areaSet.has(String(a))) continue;
            yen += toNumber(r["料金"]);
            cps += toNumber(r["部数"]);
          }
        }
      }

      return { yen, cps };
    }


    async function buildPrecomputedAsync(){
      showOverlay("初期計算中…", "人口・年齢・年収と媒体の合計を準備しています");
      setProgress(1, "開始");

      const anyRow = townIndex?.values()?.next()?.value || {};
      const incomeWidth = detectIncomeWidth(Object.keys(anyRow||{}));

      const mediaYBy = new Map(), mediaCBy = new Map();
      if (mediaIndex) {
        for (const [code, rows] of mediaIndex.entries()){
          let y=0, c=0; for (const r of rows){ y += toNumber(r["料金"]); c += toNumber(r["部数"]); }
          mediaYBy.set(code, y); mediaCBy.set(code, c);
        }
      }

      PRE.clear();
      const N = allFeatures.length;
      const CHUNK = 300;
      for (let i=0;i<N;i+=CHUNK){
        const end = Math.min(i+CHUNK, N);
        for (let j=i;j<end;j++){
          const f = allFeatures[j];
          const code = String(f.code);
          const r = townIndex.get(code);
          if (!r) continue;

          const AGE_WIDTH = 5;
          let ageW=0, ageN=0, maleW=0, maleN=0, femaleW=0, femaleN=0;
          for (const [k,v] of Object.entries(r)){
            const band = parseAgeBand(k, AGE_WIDTH); if (!band) continue;
            const mid = (band.lo + band.hi)/2, n = Number(v)||0;
            ageW += mid*n; ageN += n;
            const t = z2h(k);
            if (/^男/.test(t)){ maleW += mid*n; maleN += n; }
            else if (/^女/.test(t)){ femaleW += mid*n; femaleN += n; }
          }
          let incW=0, incN=0;
          for (const [k,v] of Object.entries(r)){
            const band = parseIncomeBand(k, incomeWidth); if (!band) continue;
            const mid = (band.lo + band.hi)/2, n = Number(v)||0;
            incW += mid*n; incN += n;
          }

          PRE.set(code, {
            ageW, ageN, maleW, maleN, femaleW, femaleN,
            incW, incN,
            yen: mediaYBy.get(code)||0,
            cps: mediaCBy.get(code)||0,
            centroid: f.centroid
          });
        }
        const pct = Math.round(((end) / N) * 100);
        setProgress(pct, `町丁目 ${end}/${N} を処理`);
        await sleep(0);
      }

      neighborCache.clear(); neighborPtr.clear();
      setProgress(100, "完了");
      overlayMsg.textContent = "初期計算が完了しました";
      setTimeout(hideOverlay, 250);

      ensureBaseIfMissing();
      renderTargetRadius();
      updateBaseFeatureState();
    }

    function tryBuildPrecomputedAsync(){
      if (!ENABLE_PRECOMPUTE) {
        // 初期計算オフモード：何もしない
        return;
      }
      if (readyTown && readyMedia && readyGeo){
        buildPrecomputedAsync().catch(e=>{
          console.error(e);
          overlayMsg.textContent = "初期計算でエラーが発生しました";
        });
      }
    }


    // ---- 四隅隣接ユーティリティ ----
    function pointInBbox(pt, bbox) {
      const [x, y] = pt;
      const [[minx, miny],[maxx, maxy]] = bbox;
      return x >= minx && x <= maxx && y >= miny && y <= maxy;
    }
    function cornersOfBbox(bbox) {
      const [[minx, miny],[maxx, maxy]] = bbox;
      return [
        [minx, miny], [minx, maxy],
        [maxx, miny], [maxx, maxy]
      ];
    }
    function hasCornerInsideBase(candidateBbox, baseBbox) {
      const cs = cornersOfBbox(candidateBbox);
      for (const p of cs) if (pointInBbox(p, baseBbox)) return true;
      return false;
    }
    function getCornerAdjacentList(baseCode) {
      const k = String(baseCode);
      if (cornerAdjCache.has(k)) return cornerAdjCache.get(k);
      const baseBbox = bboxOf(k);
      const result = [];
      if (!baseBbox) { cornerAdjCache.set(k, result); return result; }
      for (const f of allFeatures) {
        const c = String(f.code);
        if (c === k) continue;
        const bb = bboxOf(c);
        if (!bb) continue;
        if (hasCornerInsideBase(bb, baseBbox)) result.push(c);
      }
      cornerAdjCache.set(k, result);
      return result;
    }

    function isCornerExhausted(code){
      if (!USE_CORNER_ADJACENCY) return false;
      // ★追加：鉄道路線候補があり、未選択が残っているなら「枯渇」扱いにしない
      const rail = getActiveLineTownCandidates();
      if (rail && rail.size){
        for (const c of rail){
          if (!selected.has(String(c))){
            return false;
          }
        }
      }

      const k = String(code);

      // すでに判定済みならそのまま返す
      if (exhaustedCornerBase.get(k)) return true;

      const cand = getCornerAdjacentList(k);

      // ★ここがポイント★
      // 角隣接の候補が 0 件の場合は「枯渇」扱いにしないで false を返す。
      // → この町は「四隅ベースの隣接がないだけ」で、
      //    全町からの距離ソートにフォールバックさせる。
      if (cand.length === 0){
        return false;
      }

      // 候補が全部 selected に含まれているときだけ枯渇扱い
      for (const c of cand){
        if (!selected.has(String(c))){
          return false;
        }
      }
      exhaustedCornerBase.set(k, true);
      return true;
    }


    // 距離キャッシュ
    function getDistanceSortedList(origin){
      const arr = allFeatures.map(f => {
        const t = getEnabledMediaTotalsForTown(f.code);
        return {
          code: f.code,
          d: distMeters(origin, f.centroid),
          cost: t.yen,
          cps: t.cps
        };
      });
      arr.sort((a,b)=>a.d-b.d);
      return arr;
    }

    function getNeighborList(code){
      const rail = getActiveLineTownCandidates(); // ← ここで定義
      const railOn = (rail && rail.size && activeLineStationCentroids.length);

      if (isCornerExhausted(code)) {
        neighborCache.set(code, []);
        neighborPtr.set(code, 0);
        return [];
      }

      let candidates = null;
      if (USE_CORNER_ADJACENCY) {
        const a = getCornerAdjacentList(code);
        if (a.length > 0) candidates = new Set(a);
      }

      if (neighborCache.has(code)) return neighborCache.get(code);

      const c0 = centroidOf(code);
      if (!c0) return [];

      // 候補プール作成（四隅候補があるならそれ + 路線駅町）
      let pool;
      if (candidates) {
        const poolSet = new Set(candidates);
        if (railOn) {
          for (const c of rail) poolSet.add(String(c));
        }
        pool = [...poolSet];
      } else {
        pool = allFeatures.map(f => String(f.code));
      }

      const arr = [];
      for (const c of pool){
        const cc = String(c);
        if (cc === String(code)) continue;

        const centroid = PRE.get(cc)?.centroid || centroidOf(cc);
        const d = distMeters(c0, centroid);

        const m = railOn ? getRailMinDistForTown(cc) : null;
        const railMin = (m == null) ? Infinity : m;

        arr.push({ code: cc, d, railMin });
      }

      // ★路線ON：最寄り駅が近い町を優先
      if (railOn) {
        arr.sort((a,b)=>
          (a.railMin - b.railMin) || // 最寄り駅までの距離
          (a.d - b.d)                // タイブレーク：起点町距離
        );
      } else {
        arr.sort((a,b)=>a.d-b.d);
      }

      neighborCache.set(code, arr);
      neighborPtr.set(code, 0);
      return arr;
    }



    function nearestUnpickedFast(fromCode, excludeSet){
      if (isCornerExhausted(fromCode)) return null;

      const list = getNeighborList(fromCode);
      let i = neighborPtr.get(fromCode) || 0;
      let scanned = 0;
      while (i < list.length && excludeSet.has(list[i].code)) {
        i++; scanned++;
        if (scanned > MAX_SCAN) { neighborPtr.set(fromCode, i); return null; }
      }
      neighborPtr.set(fromCode, i);
      if (i < list.length) {
        touchSeed(fromCode);
        return list[i];
      }
      return null;
    }

    // ★ 業態用：
    //   「全媒体の選択町（mediaViewByName の union）」のうち、
    //   「基準の選択町（selected）に含まれる町（※基準の町は除外）」のみを対象に
    //   推測視認率 / 来店期待値を計算
    function computeGyotaiMetrics(gyotai) {
      if (!mediaIndex || !townIndex || !typeMasterByGyotai) {
        return { viewRate: null, visitRaw: null };
      }

      const rows = (pickTypeRowsForCurrentCombo(gyotai).rows || []);
      if (!rows.length) {
        return { viewRate: null, visitRaw: null };
      }

      const baseStr = baseCode ? String(baseCode) : null;

      // --- ① 全媒体の「選択町」（mediaViewByName の union）を作る ---
      //     ※ 媒体 ON/OFF（対象/除外中）はここで反映
      const allMediaSelected = new Set();
      for (const [mediaName, set] of mediaViewByName.entries()) {
        if (!isMediaEnabled(mediaName)) continue;  // OFF 媒体は union に含めない
        for (const c of set) {
          allMediaSelected.add(String(c));
        }
      }

      // --- ② そのうち「基準の選択町」に含まれるコードだけを採用（※基準の町は除外）---
      let targetCodes = [];
      if (allMediaSelected.size) {
        for (const c of allMediaSelected) {
          const s = String(c);
          if (baseStr && s === baseStr) continue;   // 基準の町は除外
          if (!selected.has(s)) continue;           // 基準選択町の範囲外は除外
          targetCodes.push(s);
        }
      }

      // --- ③ 交差が空なら、従来どおり selected（基準選択町のみ）で計算 ---
      if (!targetCodes.length) {
        targetCodes = Array.from(selected).filter(code => {
          const s = String(code);
          return !baseStr || s !== baseStr;  // 基準の町だけ除外
        });
      }

      if (!targetCodes.length) {
        return { viewRate: null, visitRaw: null };
      }

      // --- この業態に紐づく「媒体カテゴリ」一覧（type_master.媒体） ---
      const categories = new Set(
        rows
          .map(r => normalizeTypeCategory(String(r["媒体"] ?? "").trim()))
          .filter(s => s !== "")
      );
if (!categories.size) {
        return { viewRate: null, visitRaw: null };
      }

      // 媒体（= type_master.媒体 = media_master.分類）ごとの視認上限（0.3〜1.0）
      const mediaCap = new Map();
      let maxAbsContrib = 0;

      for (const r of rows) {
        const contrib = getTypeContrib(r);
        if (Number.isFinite(contrib)) {
          const abs = Math.abs(contrib);
          if (abs > maxAbsContrib) maxAbsContrib = abs;
        }
      }
      const denom = maxAbsContrib || 1;

      for (const r of rows) {
        const cat = normalizeTypeCategory(String(r["媒体"] ?? "").trim());
        if (!cat) continue;

        const contrib = getTypeContrib(r);
        const abs = Math.max(0, Math.abs(contrib));
        const normalized = abs / denom;          // 0〜1
        const cap = 0.3 + 0.7 * normalized;      // 0.3〜1.0 にマッピング

        // 同じカテゴリが複数行ある場合はいちばん大きい cap を採用
        const prev = mediaCap.get(cat);
        mediaCap.set(cat, prev != null ? Math.max(prev, cap) : cap);
      }

      const center =
        lastClickLngLat ||
        centroidOf(baseCode || "") ||
        getMapCenterLngLat();

      let hhSum   = 0;   // 世帯数の合計
      let seenSum = 0;   // 見た世帯数の合計
      let visitRaw = 0;  // 来店期待値の元（距離減衰付き指数）

      // ★ ここが重要：必ず targetCodes を使う（selectedCodes は一切使わない）
      for (const code of targetCodes) {
        const codeStr = String(code);
        const townRow = townIndex.get(codeStr);
        if (!townRow) continue;

        const hh = toNumber(townRow[HH_TOTAL_KEY] ?? 0);
        if (!hh) continue;

        const mediaRows = mediaIndex.get(codeStr);
        if (!mediaRows) continue;

        let notSeenProd = 1;  // 「見ない確率」の積
        let hasAny = false;   // この町で業態に紐づく有効媒体が1つでもあるか

        for (const r of mediaRows) {
          const cat = normalizeTypeCategory(String(r["分類"] ?? "").trim());
          if (!categories.has(cat)) continue; // 業態に紐づかない媒体は無視

          const mediaName = r["媒体名"] ?? "(名称不明)";
          if (!isMediaEnabled(mediaName)) continue;  // 除外中媒体は無視
          // 表示セット（店CD単位の増減）を反映（行単位で判定）
          if (!isRowInMediaDisplay(mediaName, codeStr, r)) continue;

          const copies = toNumber(r["部数"]);
          if (!copies) continue;

          const cap = mediaCap.get(cat) ?? 0.6;
          // 1世帯1部までを素視認率1とみなす
          const baseCov = Math.min(1, copies / hh);
          let cov = baseCov * cap;  // 0〜cap

          if (cov <= 0) continue;
          if (cov > 1) cov = 1;

          hasAny = true;
          notSeenProd *= (1 - cov);  // 見ない確率を積算
        }

        // この町に有効媒体が1つもないなら、そもそも配布対象から外す
        if (!hasAny) continue;

        const coverageTown = 1 - notSeenProd; // 0〜1

        hhSum   += hh;
        seenSum += hh * coverageTown;

        const p = PRE.get(codeStr);
        const centroid = p?.centroid || centroidOf(codeStr);
        if (centroid && center) {
          const dKm = distMeters(center, centroid) / 1000;
          const decay = 1 / (1 + dKm);
          visitRaw += hh * coverageTown * decay;
        }
      }

      const viewRate = hhSum > 0 ? (seenSum / hhSum) : null;

      return {
        viewRate,
        visitRaw: visitRaw || null
      };
    }

    // ★ 自動選択開始時はクリーンスタート（全解除 + スライダー履歴クリア + 100%）
    function resetSelectionsForAutoStart(){
      // 可能な限り「地図上で selected になっている町」を全部 OFF にする
      const allCodes = new Set();
      try {
        for (const c of selected) allCodes.add(String(c));
        for (const c of mediaViewSet) allCodes.add(String(c));
        if (mediaViewByName && typeof mediaViewByName.values === 'function') {
          for (const s of mediaViewByName.values()) {
            if (!s) continue;
            for (const c of s) allCodes.add(String(c));
          }
        }
        if (mediaDisplayByName && typeof mediaDisplayByName.values === 'function') {
          for (const s of mediaDisplayByName.values()) {
            if (!s) continue;
            for (const c of s) allCodes.add(String(c));
          }
        }
      } catch (e) { /* ignore */ }

      try {
        if (map && typeof map.setFeatureState === 'function') {
          for (const code of allCodes) {
            // storeIdx は媒体ビューで使うので念のため 0 に戻す
            map.setFeatureState({ source: 'aichi', id: code }, { selected: false, storeIdx: 0 });
          }
        }
      } catch (e) { /* ignore */ }

      // 内部状態のクリア
      try { selected.clear(); } catch(e) {}
      try { mediaViewSet.clear(); } catch(e) {}
      try { mediaViewByName.clear(); } catch(e) {}
      try { baseSelectOrder.length = 0; } catch(e) {}
      try { mediaAreaOrderByName.clear(); } catch(e) {}
      try { mediaDisplayByName.clear(); } catch(e) {}
      try { mediaDisplayAreasByName.clear(); } catch(e) {}

      // ★目標ロックも解除してクリーンスタート
      try { clearGoalLock(); } catch(e) {}

      viewMode = 'base';
      currentMediaName = null;

      // 部数調整スライダーは最大(=100%)に戻す
      try {
        if (mediaScaleByName) {
          for (const name of mediaScaleByName.keys()) mediaScaleByName.set(name, 1);
        }
      } catch (e) { /* ignore */ }
      document.querySelectorAll('input.media-scale').forEach(inp => {
        if (inp instanceof HTMLInputElement) inp.value = '100';
      });
      document.querySelectorAll('.media-scale-val').forEach(sp => { sp.textContent = '100%'; });

      resetFrontierCaches();

      // UIも更新
      applyViewSelection();
      updateAggregates();
      updateViewStatus();
      updateAttrMetrics();
      updateAutoButtonHighlight();
    }

    // 距離優先（基準セット selected を対象）
    async function runDistanceFirst(){
      resetSelectionsForAutoStart();
      const targetYen    = Math.round(toNumber($("budgetInput").value) * 10000);
      const targetCopies = Math.round(toNumber($("copiesInput").value) * 10000);
      const targetDist   = Math.round(toNumber($("distInput").value)   * 1000);

      const $out = $("selectMsg");
      if (!PRE.size) {
        $out.textContent = "初期計算の完了を待っています。";
        return;
      }

      // ★ 目標が未入力（全部 0）の場合も、そのまま距離優先で実行する
      //    targetYen / targetCopies / targetDist が 0 のままでも OK

      // 常に基準モードで実行
      viewMode = "base";
      applyViewSelection();

      ensureBaseIfMissing();
      updateBaseFeatureState();
      renderTargetRadius();

      // ★ ここで「中心点の町」を1件だけ先に選択しておく
      ensureBaseTownSelectedForAuto(targetDist);
      updateAggregates();
      updateAttrMetrics();

      beginAuto();
      try {
        // ★ 料金・部数の目標判定は「全媒体対象（対象ONのみ）」を使う
        let { yen: totalYen, cps: totalCps } = getCurrentAllMediaTotals();



        // 距離の中心は「基準の町」を最優先
        const origin =
          centroidOf(baseCode||"") ??
          lastClickLngLat ??
          getMapCenterLngLat();

          const rail = getActiveLineTownCandidates();

          let rankedAll;
          if (rail && rail.size && activeLineStationCentroids.length) {
            rankedAll = allFeatures.map(f => {
              const t = getEnabledMediaTotalsForTown(f.code);
              const d = distMeters(origin, f.centroid);

              const m = getRailMinDistForTown(f.code);
              const railMin = (m == null) ? Infinity : m;

              return { code: f.code, d, cost: t.yen, cps: t.cps, railMin };
            });

            // ★路線選択中：駅に近い町（最寄り駅距離）が優先
            rankedAll.sort((a,b)=>
              (a.railMin - b.railMin) ||
              (a.d - b.d)
            );
          } else {
            rankedAll = getDistanceSortedList(origin);
          }


        let ranked = rankedAll.filter(r => !selected.has(String(r.code)));
        let hadDistFilter = false, hasOutside = false;
        if (targetDist > 0) {
          hadDistFilter = true;
          const within = rankedAll.filter(r => r.d <= targetDist && !selected.has(String(r.code)));
          hasOutside = within.length < ranked.length;
          ranked = within;
        }

        let stoppedBy = null;
        let step = 0;
        const AUTO_UI_INTERVAL_MS = 2000;
        let lastUiUpdate = performance.now();

        for (const r of ranked) {
          if (STOP.requested) { 
            stoppedBy = 'stop';
            break;
          }

          // まず選択に追加する
          const codeStr = String(r.code);
          selected.add(codeStr);
          rememberTownAddedToBase(codeStr);
          map.setFeatureState({ source: "aichi", id: codeStr }, { selected: true });
          autoExpandMediaFromBaseTown(codeStr);
          refreshMediaDisplaysForTown(codeStr);

          // ★ 追加後の「全媒体対象（対象ONのみ）」を再計算
          ({ yen: totalYen, cps: totalCps } = getCurrentAllMediaTotals());
          picked++;

          // ★追加したあとで、目標到達（超過含む）をチェックして止める
          if (targetYen > 0 && totalYen >= targetYen) {
            stoppedBy = 'yen';
            break;
          }
          if (targetCopies > 0 && totalCps >= targetCopies) {
            stoppedBy = 'copies';
            break;
          }

          step++;
          if ((performance.now() - lastUiUpdate) >= AUTO_UI_INTERVAL_MS) {
            updateAggregates();
            updateAttrMetrics();
            await sleep(0); // 描画に譲る
            lastUiUpdate = performance.now();
          }
        }

        if (!stoppedBy && hadDistFilter && ranked.length===0 && hasOutside) stoppedBy='dist';
        updateAggregates();
        updateAttrMetrics();

        const totalYen10k    = Math.round(totalYen / 10000);
        const totalCopies10k = Math.round(totalCps / 10000);
        const yenHit    = (targetYen > 0    && (stoppedBy === 'yen'    || totalYen >= targetYen));
        const copiesHit = (targetCopies > 0 && (stoppedBy === 'copies' || totalCps >= targetCopies));
        const distHit   = (targetDist > 0   &&  stoppedBy === 'dist');
        $("budgetInput")?.classList.toggle("hit", yenHit);
        $("copiesInput")?.classList.toggle("hit", copiesHit);
        $("distInput")?.classList.toggle("hit", distHit);

        // ★ 料金/部数の目標に到達していれば、ロックモードへ（他媒体で補填/均等調整）
        // 両方設定時も「片方到達」でロックを開始し、到達した側を基準にする
        const goalHitAny = ((targetYen > 0 && totalYen >= targetYen) || (targetCopies > 0 && totalCps >= targetCopies));
        if (goalHitAny) {
          buildGoalLockFromCurrentSelection(targetYen, targetCopies, stoppedBy);
          updateAggregates();
          updateAttrMetrics();
        }

        const parts = [];
        parts.push(`町数 ${picked}件`);
        if (targetYen > 0)    parts.push(`<span class="${yenHit ? 'hitText' : ''}">料金 ${totalYen10k.toLocaleString()} / 目標 ${(targetYen/10000|0).toLocaleString()} 万円</span>`);
        if (targetCopies > 0) parts.push(`<span class="${copiesHit ? 'hitText' : ''}">部数 ${totalCopies10k.toLocaleString()} / 目標 ${(targetCopies/10000|0).toLocaleString()} 万部</span>`);
        if (targetDist > 0)   parts.push(`<span class="${distHit ? 'hitText' : ''}">半径 ${(targetDist/1000|0).toLocaleString()} km内（追加分の探索）</span>`);
        $out.innerHTML = `自動選択（距離優先）: ${parts.join(" | ")}${stoppedBy ? ` / 停止理由: ${stoppedBy}` : ""}`;
      } finally {
        finishAuto();
        // ★自動選択後、最適化ボタンを目立たせる
        emphasizeOptimizeButtons();
      }
    }

    // 目標近似（基準セット selected を対象）
    function getInitialSeeds(allowedInRadius){
      const baseStr = baseCode ? String(baseCode) : null;
      const pass = (s)=> (!allowedInRadius || allowedInRadius.has(s)) && !isCornerExhausted(s);
      const pool = [];
      for (const c of selected){
        const s = String(c);
        if (s === baseStr) continue;
        if (!pass(s)) continue;
        const t = seedLRU.get(s) ?? -1;
        pool.push({ code: s, t });
      }
      pool.sort((a,b)=> a.t - b.t);

      const room = SEED_LIMIT - (baseStr ? 1 : 0);
      const arr = pool.slice(0, Math.max(0, room)).map(x=>x.code);
      return (baseStr && pass(baseStr)) ? [baseStr, ...arr] : arr;
    }

    // ★ チェックされている属性キーを配列で返す
    function getSelectedAttributeKeys() {
      const box = $("attributeSelectBox");
      if (!box) return [];

      const keys = [];
      box.querySelectorAll(".attr-checkbox:checked").forEach(chk => {
        const key = chk.getAttribute("data-attr-key");
        if (key != null && key !== "") {
          keys.push(key);
        }
      });
      return keys;
    }

    // ★ 選択されている属性を <summary> に要約表示
    function updateAttrSummaryLabel() {
      const box = $("attributeSelectBox");
      if (!box) return;

      const details = box.closest("details");
      if (!details) return;

      const summaryEl = details.querySelector("summary");
      if (!summaryEl) return;

      const keys = getSelectedAttributeKeys();

      if (!keys.length) {
        // 何も選ばれていないときは元の表示に戻す
        summaryEl.textContent = "重視する属性を選択";
      } else {
        // 選ばれた属性だけを表示
        summaryEl.textContent = "重視する属性：" + keys.join(" / ");
      }
    }


    // ★ 基準の町 / 全媒体対象 / 媒体別の属性比較テーブル
    function updateAttrMetrics() {
      const box = $("attrMetrics");
      if (!box) return;

      if (!townIndex || !townIndex.size) {
        box.textContent = "町マスタの読み込み完了後に表示されます。";
        return;
      }

      const attrKeys = getSelectedAttributeKeys();  // 選択された属性列
      const selectedCodes = Array.from(selected).map(String);

      if (!selectedCodes.length) {
        box.textContent = "基準ビューで 1 件以上の町を選択すると、ここに指標比較を表示します。";
        return;
      }

      const baseStr = baseCode ? String(baseCode) : null;

      // ▼ 有効な媒体名（ON/OFF問わず「選択中の町に出ている媒体」全部）
      const mediaNamesInSelection = new Set();
      if (mediaIndex) {
        for (const code of selectedCodes) {
          const rowsForTown = mediaIndex.get(String(code)) || [];
          for (const r of rowsForTown) {
            const mName = r["媒体名"] ?? "(名称不明)";
            mediaNamesInSelection.add(mName);
          }
        }
      }
      const allMediaNames = Array.from(mediaNamesInSelection)
        .sort((a, b) => a.localeCompare(b, "ja"));

      // ▼ 「全媒体対象」用：対象ONの各媒体について
      //    スライダー（店CD単位の増減）を反映した「表示セット」のユニオンを作る
      const allMediaTargetSet = new Set();
      let allMediaTargetCopies = 0;
      let allMediaTargetPrice  = 0;
      if (mediaIndex && mediaCodesAllByName) {
        for (const [name] of mediaCodesAllByName.entries()) {
          // OFF の媒体は対象外
          if (!isMediaEnabled(name)) continue;

          const dispSet = getMediaDisplaySet(name);
          if (!dispSet || !dispSet.size) continue;

          for (const code of dispSet) {
            const cStr = String(code);
            allMediaTargetSet.add(cStr);

            const rowsForTown = mediaIndex.get(cStr) || [];
            for (const r of rowsForTown) {
              const rName = r["媒体名"] ?? "(名称不明)";
              if (rName !== name) continue;
              // ★ 店CD（=エリア）単位のスライダー選択を反映
              if (!isRowInMediaDisplay(name, cStr, r)) continue;
              allMediaTargetCopies += toNumber(r["部数"]);
              allMediaTargetPrice  += toNumber(r["料金"]);
            }
          }
        }
      }

      const allMediaTargetCodes = Array.from(allMediaTargetSet);

      // ▼ 指標計算ユーティリティ
      // codes       : 対象とする町コード配列
      // mediaFilter : null のとき「対象ONの全媒体」、文字列（媒体名）のときその媒体だけ
      // options     : { ignoreMediaView: true } だと媒体ビューでの町選択を無視して集計
      function calcMetrics(codes, mediaFilter = null, options = {}) {
        const ignoreMediaView = !!(options && options.ignoreMediaView);

        // 対象町がなければ全部ゼロ
        if (!codes || !codes.length) {
          return {
            hhTotal: 0,
            popTotal: 0,
            copiesTotal: 0,
            priceTotal: 0,
            avgAge: null,
            maleAvgAge: null,
            femaleAvgAge: null,
            avgIncome: null,
            carRate: null,
            subRate: null,
            attrHhRate: null,
            attrPopRate: null,
            hasAttr: !!attrKeys.length,
            viewRate: null,
            visitRaw: null,
            costPerVisit: null
          };
        }

        // ========= 業態別媒体別指数（cap）を準備 =========
        let categories = null;  // この業態で使う「媒体カテゴリ」集合
        let mediaCap   = null;  // 媒体カテゴリ → cap(0.3〜1.0)

        const typeSel = document.getElementById("typeSelect");
        if (typeMasterByGyotai && typeSel && typeSel.value) {
          const rows = (pickTypeRowsForCurrentCombo(typeSel.value).rows || []);
          if (rows.length) {
            categories = new Set();
            mediaCap   = new Map();

            // 貢献度の絶対値の最大を取る
            let maxAbsContrib = 0;
            for (const r of rows) {
              const contrib = getTypeContrib(r);
              if (!Number.isFinite(contrib)) continue;
              const abs = Math.abs(contrib);
              if (abs > maxAbsContrib) maxAbsContrib = abs;
            }
            const denom = maxAbsContrib || 1;

            // 媒体カテゴリごとの cap（0.3〜1.0）を計算
            for (const r of rows) {
              const cat = String(r["媒体"] ?? "").trim();
              if (!cat) continue;

              const contrib = getTypeContrib(r);
              const abs = Math.max(0, Math.abs(contrib));
              const normalized = abs / denom;        // 0〜1
              const cap = 0.3 + 0.7 * normalized;    // 0.3〜1.0

              const prev = mediaCap.get(cat);
              mediaCap.set(cat, prev != null ? Math.max(prev, cap) : cap);
              categories.add(cat);
            }
          }
        }

        // 業態が選択されていて、かつ cap が作れたときだけ業態ロジックを使う
        const useGyotaiCaps =
          !!(categories && categories.size && mediaCap && mediaCap.size);

        // ========= 共通集計部分 =========
        let hhTotal = 0;
        let popTotal = 0;
        let copiesTotal = 0;
        let priceTotal = 0;

        let carWeighted = 0;
        let carDen = 0;

        let ageW = 0, ageN = 0;
        let incW = 0, incN = 0;

        let maleAgeW = 0, maleAgeN = 0;
        let femaleAgeW = 0, femaleAgeN = 0;

        let attrTotal = 0;

        // 推測視認率・来店期待値用
        let hhSumForView = 0;
        let seenSum = 0;
        let visitRaw = 0;

        const baseStr = baseCode ? String(baseCode) : null;
        const centerLngLat =
          lastClickLngLat ||
          (baseStr ? (PRE.get(baseStr)?.centroid || centroidOf(baseStr)) : null) ||
          getMapCenterLngLat();

        for (const code0 of codes) {
          const codeStr = String(code0);
          const row = townIndex.get(codeStr);
          if (!row) continue;

          const hh  = toNumber(row[HH_TOTAL_KEY]  ?? 0);
          const pop = toNumber(row[POP_TOTAL_KEY] ?? 0);
          hhTotal  += hh;
          popTotal += pop;

          // 自動車保有率（世帯加重平均）
          const car = toNumber(row[CAR_AVG_KEY] ?? 0);
          if (hh > 0 && Number.isFinite(car)) {
            carWeighted += car * hh;
            carDen      += hh;
          }

          // 事前計算済みの平均年齢・年収など
          const p = PRE.get(codeStr);
          if (p) {
            ageW += p.ageW;
            ageN += p.ageN;
            incW += p.incW;
            incN += p.incN;

            maleAgeW   += p.maleW;
            maleAgeN   += p.maleN;
            femaleAgeW += p.femaleW;
            femaleAgeN += p.femaleN;
          }

          // 属性列の合計
          if (attrKeys.length) {
            let attrSumTown = 0;
            for (const key of attrKeys) {
              attrSumTown += toNumber(row[key]);
            }
            attrTotal += attrSumTown;
          }

          // -------- 媒体ごとの部数・料金・coverage --------
          let copiesInTown = 0;
          let priceInTown  = 0;

          let notSeenProd = 1;        // 「見ない確率」の積
          let hasAnyCapMedia = false; // 業態に紐づく有効媒体があるか

          const rowsForTown = mediaIndex ? (mediaIndex.get(codeStr) || []) : [];

          for (const mr of rowsForTown) {
            const mediaName = mr["媒体名"] ?? "(名称不明)";

            // 媒体ON/OFF + mediaFilter
            if (mediaFilter) {
              // 媒体行：この媒体だけ
              if (mediaName !== mediaFilter) continue;
              if (!isMediaEnabled(mediaName)) continue;
            } else {
              // 基準行・全媒体行：対象ONの媒体だけ
              if (!isMediaEnabled(mediaName)) continue;
            }

            // 媒体ビューでの町選択を反映（ignoreMediaView のときは無視）
            if (!ignoreMediaView &&
                typeof mediaViewByName !== "undefined" && mediaViewByName) {
              const set = mediaViewByName.get(mediaName);
              if (set && !set.has(codeStr)) continue;
            }
            // ★ 部数調整ゲージは「店CD単位の選択」として扱う（行単位で判定）
            if (!isRowInMediaDisplay(mediaName, codeStr, mr)) continue;

            const cps   = toNumber(mr["部数"]);
            const price = toNumber(mr["料金"]);

            copiesInTown += cps;
            priceInTown  += price;

            // 業態指数を使う場合だけ、視認率ロジックに乗せる
            if (useGyotaiCaps && hh > 0 && cps > 0) {
              const cat = String(mr["分類"] ?? "").trim();
              if (!categories.has(cat)) {
                // この業態に紐づかない媒体は視認率には効かせない（部数・料金には加算済み）
                continue;
              }

              const cap = mediaCap.get(cat);
              if (!cap || cap <= 0) continue;

              let baseCov = cps / hh;
              if (baseCov > 1) baseCov = 1;
              if (baseCov <= 0) continue;

              let cov = baseCov * cap;   // 0〜cap
              if (cov > 1) cov = 1;
              if (cov <= 0) continue;

              hasAnyCapMedia = true;
              notSeenProd *= (1 - cov);  // 見ない確率を掛けていく
            }
          }

          // 全体用の部数・料金合計
          copiesTotal += copiesInTown;
          priceTotal  += priceInTown;

          // ---- 業態が選択されているときだけ「推測視認率」「来店期待値」を計算 ----
          if (useGyotaiCaps && centerLngLat && hh > 0 && hasAnyCapMedia) {
            const coverageTown = 1 - notSeenProd;  // 0〜1
            if (coverageTown > 0) {
              hhSumForView += hh;
              seenSum      += hh * coverageTown;

              const pTown = PRE.get(codeStr);
              const centroid = pTown?.centroid || centroidOf(codeStr);
              if (centroid) {
                const dKm = distMeters(centerLngLat, centroid) / 1000;
                const decay = 1 / (1 + dKm);       // 業態指標と同じ距離減衰
                visitRaw += hh * coverageTown * decay;
              }
            }
          }
        }

        const hasAttr = !!attrKeys.length;
        const avgAge       = ageN       ? (ageW       / ageN)       : null;
        const maleAvgAge   = maleAgeN   ? (maleAgeW   / maleAgeN)   : null;
        const femaleAvgAge = femaleAgeN ? (femaleAgeW / femaleAgeN) : null;
        const avgIncome    = incN       ? (incW       / incN)       : null;
        const carRate      = carDen     ? (carWeighted / carDen)    : null;
        const subRate      = (hhTotal > 0 && copiesTotal > 0) ? (copiesTotal / hhTotal) : null;
        const attrHhRate   = hasAttr && hhTotal  > 0 && attrTotal > 0 ? (attrTotal / hhTotal)  : null;
        const attrPopRate  = hasAttr && popTotal > 0 && attrTotal > 0 ? (attrTotal / popTotal) : null;

        // ★ 業態が選択されていないときは viewRate / visitRaw は null のまま
        const viewRate    = (hhSumForView > 0 && seenSum > 0) ? (seenSum / hhSumForView) : null;
        const visitMetric = (visitRaw > 0) ? visitRaw : null;
        const costPerVisit =
          (visitMetric && priceTotal > 0)
            ? (priceTotal / visitMetric)
            : null;

        return {
          hhTotal,
          popTotal,
          copiesTotal,
          priceTotal,
          avgAge,
          maleAvgAge,
          femaleAvgAge,
          avgIncome,
          carRate,
          subRate,
          attrHhRate,
          attrPopRate,
          hasAttr,
          // 業態指数 cap を掛けた推測視認率・来店期待値・コスパ
          viewRate,
          visitRaw: visitMetric,
          costPerVisit
        };
      }


      const fmtInt = (v) => {
        if (v == null || !Number.isFinite(v)) return "-";
        return Math.round(v).toLocaleString();
      };
      const fmt1 = (v, unit = "") => {
        if (v == null || !Number.isFinite(v)) return "-";
        const n = Math.round(v * 10) / 10;
        return n.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + unit;
      };
      const fmtPct = (v) => {
        if (v == null || !Number.isFinite(v)) return "-";
        const n = Math.round(v * 1000) / 10;
        return n.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + "%";
      };

      // ▼ コスパ計算用の「基準の町だけの指数/世帯数」を準備
      let baseMetricAll = null;                  // 全媒体対象用
      const baseMetricByMedia = new Map();       // 媒体名 → 基準値

      if (baseStr && townIndex.has(baseStr)) {
        // 全媒体対象の基準値（業態選択時は来店期待値、なければ世帯数）
        const baseAllMetrics = calcMetrics([baseStr], null, { ignoreMediaView: true });
        if (baseAllMetrics) {
          if (baseAllMetrics.visitRaw && baseAllMetrics.visitRaw > 0) {
            // 業態選択時：基準の町の「来店期待値」
            baseMetricAll = baseAllMetrics.visitRaw;
          } else if (baseAllMetrics.hhTotal > 0) {
            // 業態未選択時：基準の町の「世帯数」
            baseMetricAll = baseAllMetrics.hhTotal;
          }
        }

        // 媒体ごとの基準値
        for (const name of allMediaNames) {
          const mBase = calcMetrics([baseStr], name, { ignoreMediaView: true });
          if (!mBase) continue;

          let denom = null;
          if (mBase.visitRaw && mBase.visitRaw > 0) {
            // 業態選択時：この媒体の来店期待値（基準の町だけ）
            denom = mBase.visitRaw;
          } else if (mBase.hhTotal > 0) {
            // 業態未選択時：この媒体の世帯数（基準の町だけ）
            denom = mBase.hhTotal;
          }

          if (denom != null && Number.isFinite(denom) && denom > 0) {
            baseMetricByMedia.set(name, denom);
          }
        }
      }


      // ▼ 各行データを構築
      const rowsData = [];

      // 基準の町行
      if (baseStr && townIndex.has(baseStr)) {
        const row = townIndex.get(baseStr);
        const baseName =
          `${row["市区町村名"] ?? ""} ${row["町丁目名"] ?? ""}`.trim() || baseStr;

        const metricsBase = calcMetrics(selectedCodes, null);

        // ★ 業態が選ばれているときは、上部の業態指標と同じ値で上書き
        const typeSel = document.getElementById("typeSelect");
        if (typeSel && typeSel.value) {
          const gy = computeGyotaiMetrics(typeSel.value);
          if (gy && gy.viewRate != null && gy.visitRaw != null) {
            metricsBase.viewRate = gy.viewRate;
            metricsBase.visitRaw = gy.visitRaw;
            if (metricsBase.priceTotal > 0 && gy.visitRaw > 0) {
              metricsBase.costPerVisit = metricsBase.priceTotal / gy.visitRaw;
            } else {
              metricsBase.costPerVisit = null;
            }
          } else {
            metricsBase.viewRate = null;
            metricsBase.visitRaw = null;
            metricsBase.costPerVisit = null;
          }
        } else {
          // 業態未選択時は指数は出さない
          metricsBase.viewRate = null;
          metricsBase.visitRaw = null;
          metricsBase.costPerVisit = null;
        }

        rowsData.push({
          kind: "base",
          label: "基準の町",
          mediaName: null,
          enabled: true,
          metrics: metricsBase
        });
      }



      // --- 全媒体対象（対象ONの媒体のみ）---
      if (allMediaTargetCodes.length) {
        const metricsAll = calcMetrics(allMediaTargetCodes, null);

        // 部数と世帯比率購読率だけは、
        // 「基準ONの各媒体の全選択町」を反映した値で上書きする
        metricsAll.copiesTotal = allMediaTargetCopies;
        metricsAll.priceTotal  = allMediaTargetPrice;
        metricsAll.subRate =
          (metricsAll.hhTotal > 0 && allMediaTargetCopies > 0)
            ? (allMediaTargetCopies / metricsAll.hhTotal)
            : null;


        // 料金を上書きしたので、来店期待値あたりコストも整合させる
        metricsAll.costPerVisit = (metricsAll.visitRaw && allMediaTargetPrice > 0)
          ? (allMediaTargetPrice / metricsAll.visitRaw)
          : null;
        rowsData.push({
          kind: "all",
          label: "全媒体対象",
          mediaName: null,
          enabled: true,
          metrics: metricsAll
        });
      }

      // --- 媒体ごと（ON/OFFに関わらず行は必ず出す）---
      if (mediaIndex && allMediaNames.length) {
        for (const name of allMediaNames) {
          const enabled = isMediaEnabled(name);

          // ★ まず「この媒体の選択町セット」を媒体ビュー側から取得
          //    - 一度でも媒体ビューで触った媒体：必ず Set が存在
          //    - まだ触っていない媒体：undefined のまま
          let codesForMedia = Array.from(getMediaDisplaySet(name)).map(String);

          // 注：以前は mediaViewByName（媒体ビューで触った手動セット）や selectedCodes（基準ビュー）を元にしていたが、
          //     それだと「自動選択で作った31200部」以上にスライダーで増やしても、増分が codesForMedia に入らず
          //     指標（部数/料金/世帯など）が31200どまりになる。
          //     ここでは常に「表示セット（店CD=エリア単位の間引き後）」を媒体ごとの計算母集団にする。

          // ★ スライダー（店CD単位の間引き）を“各媒体行の対象町”にも反映する
          //   calcMetrics は「codes に入っている町の人口/世帯」を先に足すため、
          //   スライダーでその町の当該媒体が 0 行になっても、町集合が残っていると
          //   年齢/世帯/人口などが動かず「媒体行が変わらない」ように見える。
          //   そこで「この媒体がスライダー後も1行でも残っている町」だけに codes を絞る。
          if (mediaIndex && codesForMedia.length) {
            const filtered = [];
            for (const c0 of codesForMedia) {
              const cStr = String(c0);
              const rowsForTown = mediaIndex.get(cStr) || [];
              let keepTown = false;
              for (const r of rowsForTown) {
                const rName = r["媒体名"] ?? "(名称不明)";
                if (rName !== name) continue;
                if (!isMediaEnabled(rName)) continue;
                if (!isRowInMediaDisplay(name, cStr, r)) continue;
                keepTown = true;
                break;
              }
              if (keepTown) filtered.push(cStr);
            }
            codesForMedia = filtered;
          }

          let metrics;
          if (codesForMedia.length) {
            metrics = calcMetrics(codesForMedia, name);
// ★ 部数/料金は「表示セット(店CD単位)」の行だけで再集計して上書き（ゲージ反映）
if (mediaIndex && codesForMedia && codesForMedia.length) {
  let dispBu = 0;
  let dispRy = 0;
  for (const c0 of codesForMedia) {
    const cStr = String(c0);
    const rowsForTown = mediaIndex.get(cStr) || [];
    for (const r of rowsForTown) {
      const rName = r["媒体名"] ?? "(名称不明)";
      if (rName !== name) continue;
      if (!isMediaEnabled(rName)) continue;
      if (!isRowInMediaDisplay(name, cStr, r)) continue;
      dispBu += toNumber(r["部数"]);
      dispRy += toNumber(r["料金"]);
    }
  }
  metrics.copiesTotal = dispBu;
  metrics.priceTotal  = dispRy;
  metrics.subRate     = (metrics.hhTotal > 0 && dispBu > 0) ? (dispBu / metrics.hhTotal) : null;
  // visitRaw / viewRate は calcMetrics 側で display 行判定込みなので、costPerVisit だけ更新
  if (metrics.visitRaw && metrics.visitRaw > 0 && dispRy > 0) {
    metrics.costPerVisit = dispRy / metrics.visitRaw;
  } else {
    metrics.costPerVisit = null;
  }
}
          } else {
            // 配布していない / 媒体ビューで全部外された媒体は完全ゼロ
            metrics = {
              hhTotal: 0,
              popTotal: 0,
              copiesTotal: 0,
              priceTotal: 0,
              avgAge: null,
              maleAvgAge: null,
              femaleAvgAge: null,
              avgIncome: null,
              carRate: null,
              subRate: null,
              attrHhRate: null,
              attrPopRate: null,
              hasAttr: !!attrKeys.length,
              viewRate: null,
              visitRaw: null,
              costPerVisit: null
            };
          }



          rowsData.push({
            kind: "media",
            label: name,
            mediaName: name,
            enabled,
            metrics
          });
        }
      }

      // --- コスパを「基準の町だけの指数/世帯数」で上書き ---
      if (baseStr && townIndex.has(baseStr)) {
        for (const row of rowsData) {
          const m = row.metrics;
          if (!m) continue;

          if (row.kind === "all") {
            // 全媒体対象：基準の町の全媒体指数/世帯数で割る
            if (baseMetricAll != null &&
                Number.isFinite(baseMetricAll) &&
                baseMetricAll > 0 &&
                m.priceTotal > 0) {
              m.costPerVisit = m.priceTotal / baseMetricAll;
            } else {
              m.costPerVisit = null;
            }
          } else if (row.kind === "media") {
            // 各媒体：基準の町のその媒体の指数/世帯数で割る
            const denom = baseMetricByMedia.get(row.mediaName);
            if (denom != null &&
                Number.isFinite(denom) &&
                denom > 0 &&
                m.priceTotal > 0) {
              m.costPerVisit = m.priceTotal / denom;
            } else {
              m.costPerVisit = null;
            }
          }
          // row.kind === "base" は今まで通り（触らない）
        }
      }

      if (!rowsData.length) {
        box.textContent = "ON になっている媒体が選択中の町に存在しません。";
        return;
      }


      if (!rowsData.length) {
        box.textContent = "ON になっている媒体が選択中の町に存在しません。";
        return;
      }

      // ▼ テーブルHTML組み立て
      const headerHtml = `
        <tr>
          <th>ビュー</th>
          <th>対象</th>
          <th>媒体</th>
          <th>部数</th>
          <th>料金</th>
          <th>部数調整</th>
          <th>平均年齢</th>
          <th>男平均年齢</th>
          <th>女平均年齢</th>
          <th>平均年収</th>
          <th>自動車保有率</th>
          <th>世帯総数</th>
          <th>人口総数</th>
          <th>世帯比率購読率</th>
          <th>属性世帯比率</th>
          <th>属性人口比率</th>
          <!-- ★ ここから追加 -->
          <th>推測視認率</th>
          <th>来店期待値</th>
          <th>コスパ</th>
          <!-- ★ ここまで追加 -->
        </tr>
      `;


      const bodyHtml = rowsData.map((row, idx) => {
        const m = row.metrics;
        const isMedia = row.kind === "media";
        const isBase  = row.kind === "base";

        const isViewOn =
          (row.kind === "base"  && viewMode === "base") ||
          (row.kind === "media" && viewMode === "media" && currentMediaName === row.mediaName);

        // ビュー用チェック：基準の町＆媒体行に表示
        let viewCell = "";
        if (isBase || isMedia) {
          const dataAttrs = isMedia
            ? `data-scope-kind="media" data-media-name="${escHtml(row.mediaName)}"`
            : `data-scope-kind="base"`;
          viewCell = `
            <input
              type="checkbox"
              class="attr-view-check"
              ${dataAttrs}
              ${isViewOn ? "checked" : ""}
            >
          `;
        }

        // 対象チェック：媒体行だけ
        let targetCell = "";
        if (isMedia) {
          targetCell = `
            <input
              type="checkbox"
              class="attr-target-check"
              data-media-name="${escHtml(row.mediaName)}"
              ${row.enabled ? "checked" : ""}
            >
          `;
        }

        const rowAttrs = isMedia
          ? `data-scope-kind="media" data-media-name="${escHtml(row.mediaName)}"`
          : `data-scope-kind="${row.kind}"`;

        const disabledClass = isMedia && !row.enabled ? " media-row-disabled" : "";

        // 媒体行だけ「部数調整スライダー」を出す
        // ★目標ロック中は「ロック対象以外の媒体は非表示」にする
        let scaleCell = "";
        if (isMedia) {
          const params = getSliderParamsForMedia(row.mediaName);
          if (!params.show) {
            return "";
          }

          const wrapDisabled = (row.enabled && !params.disabled) ? "" : "disabled";
          const sliderDisabled = (row.enabled && !params.disabled) ? "" : "disabled";

          scaleCell = `
            <div class="media-scale-wrap ${wrapDisabled}" title="スライダーで配布量を調整（ダブルクリックで最大）">
              <input type="range"
                     class="media-scale"
                     min="${params.min}" max="${params.max}" step="${params.step}"
                     value="${params.value}"
                     data-media-name="${escHtml(row.mediaName)}"
                     ${sliderDisabled}>
              <span class="media-scale-val">${params.pct}%</span>
            </div>
          `;
        }

        return `
          <tr ${rowAttrs} class="${disabledClass}">
            <td class="center">${viewCell}</td>
            <td class="center">${targetCell}</td>
            <td>${escHtml(row.label)}</td>
            <td class="num">${fmtInt(m.copiesTotal)}</td>
            <td class="num">${fmtInt(m.priceTotal)}</td>              <!-- ★ 料金 -->
            <td>${scaleCell}</td>
            <td class="num">${fmt1(m.avgAge, "歳")}</td>
            <td class="num">${fmt1(m.maleAvgAge, "歳")}</td>          <!-- ★ 男平均年齢 -->
            <td class="num">${fmt1(m.femaleAvgAge, "歳")}</td>        <!-- ★ 女平均年齢 -->
            <td class="num">${fmt1(m.avgIncome, "万円")}</td>
            <td class="num">${fmt1(m.carRate, "台")}</td>
            <td class="num">${fmtInt(m.hhTotal)}</td>
            <td class="num">${fmtInt(m.popTotal)}</td>
            <td class="num">${fmtPct(m.subRate)}</td>
            <td class="num">${m.hasAttr ? fmtPct(m.attrHhRate)  : "-"}</td>
            <td class="num">${m.hasAttr ? fmtPct(m.attrPopRate) : "-"}</td>
            <!-- ★ ここから追加 -->
            <td class="num">${fmtPct(m.viewRate)}</td>
            <td class="num">${fmtInt(m.visitRaw)}</td>
            <td class="num">${fmt1(m.costPerVisit, "円/人")}</td>
            <!-- ★ ここまで追加 -->

          </tr>
        `;
      }).join("");

      box.innerHTML = `
        <div class="attr-metrics-scroll">
          <table>
            <thead>${headerHtml}</thead>
            <tbody>${bodyHtml}</tbody>
          </table>
        </div>
      `;
    }



    // ★ 属性優先：選択した属性の「人口比率」が高くなるように自動選択
    async function runAttributeFocus() {
      resetSelectionsForAutoStart();

      const msg = $("selectMsg");
      const attrKeys = getSelectedAttributeKeys();

      const targetYen    = Math.round(toNumber($("budgetInput").value) * 10000);
      const targetCopies = Math.round(toNumber($("copiesInput").value) * 10000);
      const targetDist   = Math.round(toNumber($("distInput").value)   * 1000);

      if (!townIndex || !allFeatures.length || !PRE.size) {
        msg.textContent = "初期計算の完了を待っています。";
        return;
      }
      if (!attrKeys.length) {
        msg.textContent = "重視する属性を1つ以上選択してください。";
        return;
      }

      // ビューは必ず基準ビューで実行
      viewMode = "base";
      applyViewSelection();

      ensureBaseIfMissing();
      updateBaseFeatureState();
      renderTargetRadius();

      // ★ スタート時に何も選択されていなければ中心点の町を先に選ぶ
      ensureBaseTownSelectedForAuto(targetDist);
      updateAggregates();
      updateAttrMetrics();

      beginAuto();
      try {
        $("budgetInput")?.classList.remove("hit");
        $("copiesInput")?.classList.remove("hit");
        $("distInput")?.classList.remove("hit");

        const centerForRadius =
        centroidOf(baseCode || "") ??
        lastClickLngLat ??
        getMapCenterLngLat();

        // 半径制約（km → m）は既に targetDist に反映済み
        let allowedInRadius = null;
        if (targetDist > 0 && centerForRadius) {
          allowedInRadius = new Set();
          for (const f of allFeatures) {
            const p = PRE.get(String(f.code));
            if (!p) continue;
            if (distMeters(centerForRadius, p.centroid) <= targetDist) {
              allowedInRadius.add(String(f.code));
            }
          }
        }
        const inRadiusFast = (code) =>
          !allowedInRadius || allowedInRadius.has(String(code));

        // 属性値と母数人口を取り出す
        function getAttrStat(code) {
          const row = townIndex.get(String(code));
          if (!row) return { attr: 0, basePop: 0 };
          let attr = 0;
          for (const key of attrKeys) {
            attr += toNumber(row[key]);
          }
          const basePop = toNumber(row[POP_TOTAL_KEY] ?? 0);
          return { attr, basePop };
        }

        let attrTotal = 0;
        let popTotal  = 0;

        // すでに選択されている町はスタート時から集計に含める（属性だけ）
        for (const c of selected) {
          if (!inRadiusFast(c)) continue;
          const { attr, basePop } = getAttrStat(c);
          attrTotal += attr;
          popTotal  += basePop;
        }

        // ★ 料金・部数は「全媒体対象（対象ONのみ）」で集計
        let { yen: totalYen, cps: totalCps } = getCurrentAllMediaTotals();

        const baseStr = baseCode ? String(baseCode) : null;
        const center  = centerForRadius;

        // ★ 1件も選ばれていない場合は「属性比率が高い町」を最初に1件選ぶ
        if (selected.size === 0) {
          let bestFirst = null;

          for (const f of allFeatures) {
            const code = String(f.code);
            if (!inRadiusFast(code)) continue;

            const { attr, basePop } = getAttrStat(code);
            if (basePop <= 0 || attr <= 0) continue;

            // ★ ここも ON 媒体だけの全媒体対象を使う
            const t = getEnabledMediaTotalsForTown(code);
            const nextY = totalYen + t.yen;
            const nextC = totalCps + t.cps;
            if ((targetYen > 0 && nextY > targetYen) ||
                (targetCopies > 0 && nextC > targetCopies)) {
              continue;
            }

            const p = PRE.get(code);
            const ratio = attr / basePop;
            const d = center
              ? distMeters(center, p?.centroid || centroidOf(code))
              : 0;

            if (!bestFirst ||
                ratio > bestFirst.ratio ||
                (ratio === bestFirst.ratio && d < bestFirst.d)) {
              bestFirst = { code, ratio, d, attr, basePop, nextY, nextC };
            }
          }

          if (!bestFirst) {
            msg.textContent = "距離・予算条件内で選択した属性を持つ候補町が見つかりませんでした。";
            finishAuto();
            return;
          }

          selected.add(bestFirst.code);
          rememberTownAddedToBase(bestFirst.code);
          attrTotal += bestFirst.attr;
          popTotal  += bestFirst.basePop;
          totalYen   = bestFirst.nextY;
          totalCps   = bestFirst.nextC;

          map.setFeatureState(
            { source: "aichi", id: bestFirst.code },
            { selected: true }
          );
          if (!seedLRU.has(bestFirst.code)) seedLRU.set(bestFirst.code, -1);
          autoExpandMediaFromBaseTown(String(bestFirst.code));
          refreshMediaDisplaysForTown(bestFirst.code);

          if (!baseStr) {
            baseCode = String(bestFirst.code);
            updateBaseFeatureState();
            renderTargetRadius();
          }

          updateAggregates();
          await sleep(0);
        }

        let order = getInitialSeeds(allowedInRadius);
        let stoppedBy = null;
        let step = 0;
        const AUTO_UI_INTERVAL_MS = 2000;
        let lastUiUpdate = performance.now();

        while (true) {
          if (STOP.requested) {
            stoppedBy = "stop";
            break;
          }

          // いまの frontier を構築
          const frontier = new Map();
          for (const base of order) {
            if (isCornerExhausted(base)) continue;
            const n = nearestUnpickedFast(base, selected);
            if (n) frontier.set(n.code, n);
          }
          if (frontier.size === 0) {
            stoppedBy = allowedInRadius ? "dist" : "no-candidate";
            break;
          }

          const list = [...frontier.values()];
          const cand = list.filter(n => inRadiusFast(n.code));
          if (allowedInRadius && cand.length === 0) {
            stoppedBy = "dist";
            break;
          }

          // ★ ここから：まず「スコア対象の町」を優先し、
          //    見つからなければ「スコア対象外の町」から距離優先で拾う
          let best = null;
          const fallbackCandidates = [];
          const candidates = cand.length ? cand : list;

          for (const c of candidates) {
            const code = String(c.code);
            if (selected.has(code)) continue;

            const { attr, basePop } = getAttrStat(code);

            const t = getEnabledMediaTotalsForTown(code);
            const nextY = totalYen + t.yen;
            const nextC = totalCps + t.cps;

            const newAttr = attrTotal + attr;
            const newPop  = popTotal + basePop;

            // ★ スコア計算の対象外（attr/pop が乗らないもの）は
            //    いったん fallback に退避しておく
            if ((basePop <= 0 && attr <= 0) || newPop <= 0) {
              fallbackCandidates.push({
                code,
                d: c.d,

                railMin: (activeLineStationCentroids && activeLineStationCentroids.length)
                  ? (getRailMinDistForTown(code) ?? Infinity)
                  : Infinity,


                addAttr: attr,
                addPop: basePop,
                nextY,
                nextC
              });
              continue;
            }

            // ここからは「属性比率」でスコアリング
            const newRatio = newAttr / newPop;
            const score = newRatio; // 高いほど良い

            const railOn = (activeLineStationCentroids && activeLineStationCentroids.length);
            const m = railOn ? getRailMinDistForTown(code) : null;
            const railMin = (m == null) ? Infinity : m;

            if (!best) {
              best = { code, score, d: c.d, attr, basePop, nextY, nextC, railMin };
            } else if (railOn) {
              // ★路線ON：駅に近い町を最優先、同点なら属性比率、最後に距離
              if (railMin < best.railMin ||
                (railMin === best.railMin && score > best.score) ||
                (railMin === best.railMin && score === best.score && c.d < best.d)) {
                best = { code, score, d: c.d, attr, basePop, nextY, nextC, railMin };
              }
            } else {
              // 従来
              if (score > best.score || (score === best.score && c.d < best.d)) {
                best = { code, score, d: c.d, attr, basePop, nextY, nextC };
              }
            }
          }

          if (!best) {
            // ★ スコア対象の町が 0 件だった場合、
            //    さっき退避しておいた「スコア対象外」の町から
            //    距離が近い順に 1 件だけ拾う
            if (fallbackCandidates.length) {

              if (activeLineStationCentroids && activeLineStationCentroids.length) {
                fallbackCandidates.sort((a,b)=>(a.railMin - b.railMin) || (a.d - b.d));
              } else {
                fallbackCandidates.sort((a,b)=>a.d - b.d);
              }              

              const f = fallbackCandidates[0];

              selected.add(f.code);
              rememberTownAddedToBase(f.code);
              attrTotal += f.addAttr;
              popTotal  += f.addPop;
              totalYen   = f.nextY;
              totalCps   = f.nextC;

              map.setFeatureState(
                { source: "aichi", id: f.code },
                { selected: true }
              );
              if (!seedLRU.has(f.code)) seedLRU.set(f.code, -1);
              autoExpandMediaFromBaseTown(String(f.code));
              refreshMediaDisplaysForTown(f.code);

              // 次ループ用にシードを再構築して継続
              order = getInitialSeeds(allowedInRadius);
              step++;
              if ((performance.now() - lastUiUpdate) >= AUTO_UI_INTERVAL_MS) {
                updateAggregates();
                updateAttrMetrics();
                await sleep(0); // 描画に譲る
                lastUiUpdate = performance.now();
              }

              // ★ ここで「追加後に超えたか」をチェック
              if (targetYen > 0 && totalYen >= targetYen) {
                stoppedBy = "yen";
                break;
              }
              if (targetCopies > 0 && totalCps >= targetCopies) {
                stoppedBy = "copies";
                break;
              }

              continue; // while(true) の先頭に戻る
            }

            // fallback も含めて本当に候補がない場合だけ終了
            stoppedBy =
              (targetYen > 0 || targetCopies > 0)
                ? "budget/copies"
                : (allowedInRadius ? "dist" : "no-candidate");
            break;
          }

          // ★ ここからは通常の「best」（スコア対象の町）を採用
          selected.add(best.code);
          rememberTownAddedToBase(best.code);
          attrTotal += best.attr;
          popTotal  += best.basePop;
          totalYen   = best.nextY;
          totalCps   = best.nextC;

          map.setFeatureState(
            { source: "aichi", id: best.code },
            { selected: true }
          );
          if (!seedLRU.has(best.code)) seedLRU.set(best.code, -1);
          autoExpandMediaFromBaseTown(String(best.code));
          refreshMediaDisplaysForTown(best.code);

          order = getInitialSeeds(allowedInRadius);

          // ★ ここで「追加後に超えたか」をチェック
          if (targetYen > 0 && totalYen >= targetYen) {
            stoppedBy = "yen";
            break;
          }
          if (targetCopies > 0 && totalCps >= targetCopies) {
            stoppedBy = "copies";
            break;
          }

          step++;
          if ((performance.now() - lastUiUpdate) >= AUTO_UI_INTERVAL_MS) {
            updateAggregates();
            updateAttrMetrics();
            await sleep(0); // 描画に譲る
            lastUiUpdate = performance.now();
          }
        } // ← while(true) ここで閉じる

        // ループ終了後のまとめ
        updateAggregates();
        updateAttrMetrics();

        const ratioPercent =
          popTotal > 0 ? (attrTotal / popTotal) * 100 : 0;
        const totalYen10k    = Math.round(totalYen / 10000);
        const totalCopies10k = Math.round(totalCps / 10000);

        const yenHit    = (targetYen    > 0 && (stoppedBy === "yen"    || totalYen   >= targetYen));
        const copiesHit = (targetCopies > 0 && (stoppedBy === "copies" || totalCps   >= targetCopies));
        const distHit   = (targetDist   > 0 &&  stoppedBy === "dist");

        $("budgetInput")?.classList.toggle("hit", yenHit);
        $("copiesInput")?.classList.toggle("hit", copiesHit);
        $("distInput")?.classList.toggle("hit", distHit);

        // ★ 料金/部数いずれかの目標に到達していれば、ロックモードへ
        // （両方設定時は「先に到達した側」を全媒体のゲージ基準にする）
        const goalHitAny = ((targetYen > 0 && totalYen >= targetYen) || (targetCopies > 0 && totalCps >= targetCopies));
        if (goalHitAny) {
          buildGoalLockFromCurrentSelection(targetYen, targetCopies, stoppedBy);
          updateAggregates();
          updateAttrMetrics();
        }

        const parts = [];
        parts.push(`選択 ${selected.size}件`);
        parts.push(`属性人口比率 ${ratioPercent.toFixed(1)}%`);

        const tail = [];
        if (targetYen > 0) {
          tail.push(
            `<span class="${yenHit ? "hitText" : ""}">料金 ${totalYen10k.toLocaleString()} / 目標 ${(targetYen/10000|0).toLocaleString()} 万円</span>`
          );
        }
        if (targetCopies > 0) {
          tail.push(
            `<span class="${copiesHit ? "hitText" : ""}">部数 ${totalCopies10k.toLocaleString()} / 目標 ${(targetCopies/10000|0).toLocaleString()} 万部</span>`
          );
        }
        if (targetDist > 0) {
          tail.push(
            `<span class="${distHit ? "hitText" : ""}">半径 ${(targetDist/1000|0).toLocaleString()} km内</span>`
          );
        }

        msg.innerHTML =
          `自動選択（属性優先）: ${parts.join(" | ")}` +
          (tail.length ? " | " + tail.join(" | ") : "") +
          (stoppedBy ? ` / 停止理由: ${stoppedBy}` : "");
      } finally {
        finishAuto();
        // ★自動選択後、最適化ボタンを目立たせる
        emphasizeOptimizeButtons();
      }
    }



    document.getElementById("runAutoBtn").addEventListener("click", async () => {
      // ★ 実行ボタンを押した瞬間に要約更新＋畳む
      const attrBox = $("attributeSelectBox");
      if (attrBox) {
        updateAttrSummaryLabel();   // チェックされている属性名を summary に反映

        const details = attrBox.closest("details");
        if (details) {
          details.open = false;     // ここで畳む（停止後ではなく実行時）
        }
      }

      const attrKeys = getSelectedAttributeKeys();

      if (attrKeys.length) {
        // 属性あり → 属性優先ロジック
        await runAttributeFocus();
      } else {
        // 属性なし → 距離優先ロジック
        await runDistanceFirst();
      }

      renderTargetRadius();
      updateBaseFeatureState();
    });


    // ★追加：今使っている媒体カテゴリの中から「最適組み合わせ」を選び、他媒体を除外
    document.getElementById("keepBestComboBtn")?.addEventListener("click", () => {
      const hintEl = document.getElementById("keepBestComboHint");
      if (hintEl) hintEl.textContent = "";

      const sel = document.getElementById("typeSelect");
      const gy = sel ? String(sel.value || "") : "";

      if (!gy) {
        if (hintEl) hintEl.textContent = "業態を選択すると、最適な媒体組み合わせに絞れます。";
        return;
      }

      runWithBusy(() => {
        const best = pickBestComboGroupForCurrentUsage(gy);
        if (!best) {
          if (hintEl) {
            const used = Array.from(getUsedMediaCategories()).map(normalizeTypeCategory).filter(Boolean);
            hintEl.textContent = used.length
              ? `該当する組み合わせが見つかりません（使用中: ${used.join("+")}）` 
              : "使用中の媒体がありません。";
          }
          return;
        }

        applyBestComboToEnabledMedia(best);

        const inside = getCenterInsideLabel() || "(市内外未判定)";
        const cats = (best.cats || []).map(normalizeTypeCategory).filter(Boolean);
        const metaName = best?.meta?.comboName || best?.meta?.listStr || best.key || "";
        const score = best._csvScore || {};
        const tw = (score.totalWeighted != null && Number.isFinite(score.totalWeighted))
          ? Math.round(score.totalWeighted).toLocaleString()
          : "-";
        const pw = (score.positiveWeighted != null && Number.isFinite(score.positiveWeighted))
          ? Math.round(score.positiveWeighted).toLocaleString()
          : "-";

        if (hintEl) {
          hintEl.innerHTML = `中心地: <b>${escHtml(inside)}</b> / 採用: <b>${escHtml(cats.join("+"))}</b><br>`
            + `参照組み合わせ: ${escHtml(metaName)} / 重み付き貢献度合計: ${escHtml(tw)}（正の合計: ${escHtml(pw)}）`;
        }
        const msg = document.getElementById("selectMsg");
        if (msg) msg.innerHTML = `最適組み合わせに絞りました：<b>${escHtml(cats.join("+"))}</b>（中心地: ${escHtml(inside)}）`;
      }, "最適組み合わせを選定中…");
    });


    // ★追加：最適な予算配分に振り分け（type_master_all.csv の推奨配分%を使って各媒体ゲージを調整）
    function getTypeBudgetPct(r){
      const v =
        (r && (
          r["広告予算配分_推奨(0%下限正規化%)"] ??
          r["広告予算配分_推奨(0％下限正規化%)"] ??
          r["広告予算配分_推奨(0%下限正規化%) "] ??
          r["広告予算配分_推奨(0％下限正規化%) "] ??
          r["広告予算配分_推奨(正規化%)"]
        )) ?? 0;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    function buildBudgetPctByCategory(rows){
      const map = new Map(); // cat -> pct(0-100)
      for (const r of (rows || [])){
        const cat = normalizeTypeCategory(String(r["媒体"] ?? "").trim());
        if (!cat) continue;
        const pct = getTypeBudgetPct(r);
        if (!Number.isFinite(pct)) continue;
        map.set(cat, pct);
      }
      return map;
    }

    function getCurrentYenForMediaLocked(m){
      const gains = GOAL_LOCK.areaGainByMedia.get(String(m)) || [];
      const v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(String(m)) || 0));
      let y = 0;
      for (let i=0; i<v && i<gains.length; i++) y += toNumber(gains[i]?.yen || 0);
      return y;
    }

    function pickCountForTargetYenLocked(m, targetYen){
      const name = String(m);
      const gains = GOAL_LOCK.areaGainByMedia.get(name) || [];
      const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(name) || 0));
      const len = Math.min(gains.length, maxCount);
      if (!(targetYen > 0) || len <= 0) return 0;

      let sum = 0;
      for (let i=0; i<len; i++){
        const add = toNumber(gains[i]?.yen || 0);
        const next = sum + add;
        if (next >= targetYen){
          const diffBefore = Math.abs(targetYen - sum);
          const diffAfter  = Math.abs(next - targetYen);
          return (diffAfter < diffBefore) ? (i+1) : i;
        }
        sum = next;
      }
      return len;
    }

    function getOrderedAreasForMediaNormal(m, maxSet){
      const name = String(m);
      const maxAreas = getMaxAreasForMedia(name, maxSet);
      if (!maxAreas || !maxAreas.size) return [];
      const orderArr = mediaAreaOrderByName.get(name) || [];
      let orderedAreas = [];

      if (orderArr.length) {
        orderedAreas = orderArr.map(String).filter(a => maxAreas.has(a));
      } else {
        const tmp = [];
        const seen = new Set();
        for (const c0 of baseSelectOrder) {
          const c = String(c0);
          if (!maxSet.has(c)) continue;
          const rows = mediaIndex?.get(c) || [];
          for (const r of rows) {
            const mm = r["媒体名"] ?? "(名称不明)";
            if (String(mm) !== name) continue;
            const a = getMediaAreaCodeFromRow(r, c);
            if (!maxAreas.has(a)) continue;
            if (seen.has(a)) continue;
            seen.add(a);
            tmp.push(a);
          }
        }
        orderedAreas = tmp;
      }

      // 順序配列に無いエリアは末尾に補完
      const setOrdered = new Set(orderedAreas);
      for (const a of maxAreas) {
        if (!setOrdered.has(a)) orderedAreas.push(a);
      }
      return orderedAreas;
    }

    function pickKeepNForTargetYenNormal(m, targetYen, orderedAreas, maxSet){
      const name = String(m);
      const len = (orderedAreas || []).length;
      if (!(targetYen > 0) || len <= 0) return 0;

      let sum = 0;
      for (let i=0; i<len; i++){
        const gain = computeAreaGainForMedia(name, orderedAreas[i], maxSet);
        const add = toNumber(gain?.yen || 0);
        const next = sum + add;
        if (next >= targetYen){
          const diffBefore = Math.abs(targetYen - sum);
          const diffAfter  = Math.abs(next - targetYen);
          return (diffAfter < diffBefore) ? (i+1) : i;
        }
        sum = next;
      }
      return len;
    }

    
    document.getElementById("applyOptimalBudgetBtn")?.addEventListener("click", () => {
      const sel = document.getElementById("typeSelect");
      const gy = sel ? String(sel.value || "") : "";
      const msg = document.getElementById("selectMsg");

      if (!gy) {
        if (msg) msg.innerHTML = "業態を選択してから「最適予算配分にする」を押してください。";
        return;
      }

      runWithBusy(() => {
        const picked = pickTypeRowsForCurrentCombo(gy);
        const rows = picked?.rows || [];
        const inside = getCenterInsideLabel() || "(市内外未判定)";

        const pctByCat = buildBudgetPctByCategory(rows);
        if (!pctByCat.size) {
          if (msg) msg.innerHTML = "この業態の予算配分（type_master_all.csv）が見つかりません。";
          return;
        }

        // チェックON媒体（ゲージ0含む）だけを対象にする
        const enabledMedias = [];
        for (const m0 of getAllMediaNames()){
          const m = String(m0);
          if (!isMediaEnabled(m)) continue;
          enabledMedias.push(m);
        }
        if (!enabledMedias.length) {
          if (msg) msg.innerHTML = "対象媒体（チェックON）がありません。";
          return;
        }

        // cat -> medias（正規化カテゴリでまとめる）
        const mediaByCatLocal = new Map();
        for (const m of enabledMedias){
          const cat = normalizeTypeCategory(mediaCategoryByName.get(m) || "");
          if (!cat) continue;
          if (!mediaByCatLocal.has(cat)) mediaByCatLocal.set(cat, []);
          mediaByCatLocal.get(cat).push(m);
        }

        // 目標予算があればそれを優先。無ければ現状の全媒体合計(料金)を固定して配分。
        let totalBudget = 0;
        if (isGoalLockOn() && (GOAL_LOCK.targetYen > 0)) {
          totalBudget = GOAL_LOCK.targetYen;
        } else {
          const tot0 = isGoalLockOn() ? getCurrentAllMediaTotalsLocked() : getCurrentAllMediaTotals();
          totalBudget = Math.max(0, Math.round(tot0.yen || 0));
        }
        if (!(totalBudget > 0)) {
          if (msg) msg.innerHTML = "予算（料金）が 0 のため、配分できません。";
          return;
        }

        // catState を構築（カテゴリ目標に達したら、そのカテゴリは終了）
        // ※ 配分%はCSVの全体比率をそのまま採用（存在しないカテゴリ分は未配分として残す）
        const catEntries = [];
        for (const [cat, pct] of pctByCat.entries()){
          const list = (mediaByCatLocal.get(cat) || []).slice();
          if (!list.length) continue;
          const p = Math.max(0, Math.min(100, Number(pct)));
          catEntries.push({ cat, pct: p, medias: list });
        }
        if (!catEntries.length) {
          if (msg) msg.innerHTML = "この配分に該当するカテゴリの媒体が現在の構成にありません。";
          return;
        }

        // ★ここでは「再正規化」しない
        // type_master_all.csv の配分%は「全体予算に対する比率」なので、
        // 現在の構成に存在しないカテゴリがあっても、残りカテゴリに上乗せせず「未配分」として残す。
        let sumPct = 0;
        for (const e of catEntries) sumPct += e.pct;

        if (!(sumPct > 0)) {
          if (msg) msg.innerHTML = "この業態の予算配分が 0% のため、配分できません。";
          return;
        }

        const catState = new Map();
        for (const e of catEntries){
          const pEff = Math.max(0, Math.min(1, e.pct / 100)); // CSVの%をそのまま使用
          const tgt = Math.max(0, Math.round(totalBudget * pEff));
          // max: このカテゴリで物理的に積める上限（後で算出）
          catState.set(e.cat, { target: tgt, total: 0, max: 0, medias: e.medias, done: false });
        }

        if (isGoalLockOn()) {
          // ===== 目標ロック中：店CD数スライダー（valueCount）を毎回 0 から積み上げ =====
          // activeMediaSet は「チェックON」のみを正とする
          GOAL_LOCK.activeMediaSet = new Set(enabledMedias);

          for (const m of enabledMedias){
            ensureGoalLockMediaPrepared(m);
            GOAL_LOCK.valueCountByMedia.set(m, 0); // ★毎回ゼロから
          }

          // ★カテゴリごとの「物理上限（max）」を算出（この上限を超える目標は達成不可）
          for (const [cat, st] of catState.entries()) {
            let maxCat = 0;
            for (const m of st.medias) {
              const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
              const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || gains.length || 0));
              let sum = 0;
              for (let i = 0; i < Math.min(maxCount, gains.length); i++) sum += toNumber(gains[i]?.yen || 0);
              maxCat += sum;
            }
            st.max = Math.max(0, Math.round(maxCat));
          }

          let guard = 0;
          while (guard < 500000){
            let progressed = false;
            let anyOpen = false;

            for (const [cat, st] of catState.entries()){
              if (st.done) continue;
              anyOpen = true;

              if (st.target <= 0 || st.total >= st.target) {
                st.done = true;
                continue;
              }

              let catProgress = false;
              for (const m of st.medias){
                if (st.total >= st.target) { st.done = true; break; }

                const v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
                const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
                if (v >= maxCount) continue;

                const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
                const add = toNumber(gains[v]?.yen || 0);

                GOAL_LOCK.valueCountByMedia.set(m, v + 1);
                st.total += add;

                progressed = true;
                catProgress = true;
              }

              if (!st.done && !catProgress) st.done = true; // これ以上増やせない
            }

            if (!anyOpen || !progressed) break;
            guard++;
          }

          // 画面反映（まとめて）
          for (const m of enabledMedias){
            recomputeMediaDisplaySet(m);
            updateSliderUIForMedia(m);
          }

        } else {
          // ===== 通常（％スライダー）：各媒体を 0 から同時に積み上げ、カテゴリ目標で停止 =====
          // まず対象媒体を 0% に戻す（毎回ゼロから）
          const keepNByMedia = new Map(); // m -> keepN(areas)
          const areasByMedia = new Map(); // m -> orderedAreas[]
          const yenByMediaArea = new Map(); // m -> yen array per area index

          for (const m of enabledMedias){
            setMediaScale(m, 0);
            keepNByMedia.set(m, 0);

            const maxSet = getMaxCodesForMedia(m);
            const orderedAreas = getOrderedAreasForMediaNormal(m, maxSet);
            areasByMedia.set(m, orderedAreas);

            const yenArr = [];
            for (let i=0; i<orderedAreas.length; i++){
              const g = computeAreaGainForMedia(m, orderedAreas[i], maxSet);
              yenArr.push(toNumber(g?.yen || 0));
            }
            yenByMediaArea.set(m, yenArr);
          }

          // ★カテゴリごとの「物理上限（max）」を算出（この上限を超える目標は達成不可）
          for (const [cat, st] of catState.entries()) {
            let maxCat = 0;
            for (const m of st.medias) {
              const yenArr = yenByMediaArea.get(m) || [];
              let sum = 0;
              for (let i = 0; i < yenArr.length; i++) sum += toNumber(yenArr[i] || 0);
              maxCat += sum;
            }
            st.max = Math.max(0, Math.round(maxCat));
          }

          let guard = 0;
          while (guard < 500000){
            let progressed = false;
            let anyOpen = false;

            for (const [cat, st] of catState.entries()){
              if (st.done) continue;
              anyOpen = true;

              if (st.target <= 0 || st.total >= st.target) {
                st.done = true;
                continue;
              }

              let catProgress = false;
              for (const m of st.medias){
                if (st.total >= st.target) { st.done = true; break; }

                const orderedAreas = areasByMedia.get(m) || [];
                const v = keepNByMedia.get(m) || 0;
                if (v >= orderedAreas.length) continue;

                const add = (yenByMediaArea.get(m) || [])[v] || 0;
                keepNByMedia.set(m, v + 1);
                st.total += add;

                progressed = true;
                catProgress = true;
              }

              if (!st.done && !catProgress) st.done = true;
            }

            if (!anyOpen || !progressed) break;
            guard++;
          }

          // スライダー（％）に反映
          for (const m of enabledMedias){
            const orderedAreas = areasByMedia.get(m) || [];
            const keepN = Math.max(0, Math.round(keepNByMedia.get(m) || 0));
            const scale = orderedAreas.length ? (keepN / orderedAreas.length) : 0;
            setMediaScale(m, Math.max(0, Math.min(1, scale)));
            recomputeMediaDisplaySet(m);
            updateSliderUIForMedia(m);
          }
        }

        // 媒体ビュー中なら、表示している媒体のセットを同期（地図更新）
        syncMediaViewSetIfNeeded();

        // 画面反映
        applyViewSelection();
        updateAggregates();
        updateAttrMetrics();
        updateBaseFeatureState();

        if (msg) {
          const cats = Array.from(pctByCat.keys()).join("+");
          const total10k = Math.round(totalBudget / 10000);
          {
            const parts = [];
            // カテゴリ別の目標と実績を表示
            const details = [];
            for (const [cat, st] of catState.entries()){
              const tgt10k = Math.round((st.target||0)/10000);
              const act10k = Math.round((st.total||0)/10000);
              const max10k = Math.round((st.max||0)/10000);
              const capped = (st.max>0 && st.target>st.max) ? "※上限" : "";
              details.push(`${cat}:${act10k}/${tgt10k}万円(最大${max10k}万円)${capped}`);
            }
            const unalloc = Math.max(0, totalBudget - Array.from(catState.values()).reduce((a,s)=>a+(s.target||0),0));
            const un10k = Math.round(unalloc/10000);
            msg.innerHTML = `最適予算配分を適用しました：<b>${escHtml(cats)}</b> / 中心地: ${escHtml(inside)} / 予算: ${total10k.toLocaleString()} 万円` 
              + `<br><span class="muted">カテゴリ別(実績/目標)：${escHtml(details.join(" / "))}${un10k>0?` / 未配分:${un10k.toLocaleString()}万円`:``}</span>`;
          }
        }
      }, "最適予算配分を適用中…");
    });





    // レポート出力ボタン
    document.getElementById("exportReportBtn")?.addEventListener("click", exportReportCsv);

    
    // ★ 提案レポート（印刷 / PDF）2段階式
    document.getElementById("proposalReportBtn")?.addEventListener("click", async () => {
      const btn = document.getElementById("proposalReportBtn");
      if (!btn) return;

      // まだ HTML が準備できていない → 準備フェーズ
      if (!pendingReportHtml) {
        const originalLabel = btn.textContent;
        btn.disabled = true;
        btn.textContent = "レポート準備中…";
        btn.classList.remove("report-ready"); // 念のためリセット

        const html = await buildProposalReportHtml();

        btn.disabled = false;

        if (!html) {
          // 失敗したら元に戻す
          btn.textContent = originalLabel;
          btn.classList.remove("report-ready");
          return;
        }

        pendingReportHtml = html;
        btn.textContent = "レポートを開く";
        btn.classList.add("report-ready");   // ★ ここで強調オン
        return; // ← 一旦終了
      }

      // HTML 準備済み → レポートを開くフェーズ
      const w = window.open("", "_blank");
      if (!w) {
        alert("ポップアップがブロックされました。\nブラウザの設定で localhost のポップアップを許可してください。");
        return;
      }

      w.document.open();
      w.document.write(pendingReportHtml);
      w.document.close();

      // 1回開いたらクリア＆ボタン表示を元に戻す
      pendingReportHtml = null;
      btn.textContent = "提案レポート（印刷 / PDF）";
      btn.classList.remove("report-ready");   // ★ 強調オフ
    });




    // ★ 業態ビューの描画本体（セレクト変更＆再計算ボタンから共通で呼ぶ）
    function renderTypeMetrics() {
      const sel = $("typeSelect");
      const box = $("typeList");
      if (!sel || !box) return;

      const val = sel.value;

      if (!val) {
        box.textContent = "業態を選ぶと、媒体ごとの SHAP / 貢献度（媒体組み合わせ別）と、選択中配布町ベースの 推測視認率 / 来店期待値 を表示します。";
        return;
      }

      const pick = pickTypeRowsForCurrentCombo(val);
      const rows = pick.rows || [];

      if (!rows.length) {
        box.textContent = "この業態のデータがありません。";
        return;
      }

      const hasCombo = (rows[0] && (rows[0]["採用媒体一覧"] != null || rows[0]["組み合わせ名"] != null));
      const showBudget = hasCombo && (rows[0]["広告予算配分_推奨(0%下限正規化%)"] != null || rows[0]["広告予算配分_推奨(RAW比)"] != null);

      // 媒体ごとの一覧（組み合わせ別）
      const htmlRows = rows.map(r => {
        const media = (r["媒体"] ?? "");
        const shap = getTypeShap(r);
        const contrib = getTypeContrib(r);

        // 予算配分（あるときだけ）
        const recNorm = (r["広告予算配分_推奨(0%下限正規化%)"] != null) ? Number(r["広告予算配分_推奨(0%下限正規化%)"]) : null;
        const recRaw  = (r["広告予算配分_推奨(RAW比)"] != null) ? Number(r["広告予算配分_推奨(RAW比)"]) : null;

        return `
          <tr>
            <td>${escHtml(media)}</td>
            <td class="num">${Number.isFinite(shap) ? shap.toFixed(4) : ""}</td>
            <td class="num">${Number.isFinite(contrib) ? contrib.toFixed(2) : ""}</td>
            ${showBudget ? `<td class="num">${Number.isFinite(recNorm) ? recNorm.toFixed(1) : (Number.isFinite(recRaw) ? recRaw.toFixed(1) : "")}</td>` : ``}
          </tr>
        `;
      }).join("");

      // 組み合わせの説明（使っている媒体カテゴリ → マッチした組み合わせ）
      let comboInfo = "";
      if (hasCombo) {
        const usedCats = Array.from(getUsedMediaCategories()).sort((a,b)=>a.localeCompare(b,"ja"));
        const usedText = usedCats.length ? usedCats.join(" + ") : "（未確定）";
        const matched = pick?.meta?.comboName || (rows[0]["組み合わせ名"] ?? "");
        const listStr = pick?.meta?.listStr || (rows[0]["採用媒体一覧"] ?? "");
        const matchNote =
          pick.match === "exact"   ? "一致" :
          pick.match === "subset"  ? "部分一致（データがある最大の組み合わせに寄せています）" :
          pick.match === "closest" ? "近い組み合わせ（完全一致がないため）" :
          "（業態のみ）";

        comboInfo = `
          <div class="muted" style="font-size:11px;margin:6px 0 2px;">
            中心地：<b>${escHtml(getCenterInsideLabel() || "（不明）")}</b><br>
            使用中の媒体カテゴリ：<b>${escHtml(usedText)}</b><br>
            参照した組み合わせ：<b>${escHtml(matched || listStr || "不明")}</b>（${escHtml(matchNote)}）
          </div>
        `;
      }

      // 推測視認率＆来店期待値（組み合わせ別の cap を使う）
      const metrics = computeGyotaiMetrics(val);

      let summaryHtml = "";
      if (metrics.viewRate != null || metrics.visitRaw != null) {
        const viewPct    = metrics.viewRate != null ? (metrics.viewRate * 100).toFixed(1) : null;
        const visitIndex = metrics.visitRaw  != null ? Math.round(metrics.visitRaw)       : null;

        summaryHtml = `
          <div class="type-metrics-box">
            <div class="type-metrics-row">
              <span class="type-metrics-label">推測視認率（選択中配布町ベース）</span>
              <span class="type-metrics-value">${viewPct !== null ? `${viewPct}%` : `-`}</span>
            </div>
            <div class="type-metrics-row">
              <span class="type-metrics-label">来店期待値（距離減衰付き指数）</span>
              <span class="type-metrics-value">${visitIndex !== null ? visitIndex.toLocaleString() : `-`}</span>
            </div>
          </div>
        `;
      } else {
        summaryHtml = `
          <div class="type-metrics-box">
            <div class="type-metrics-row">
              <span class="type-metrics-label">推測視認率 / 来店期待値</span>
              <span class="type-metrics-value" style="font-size:14px;">計算対象となる配布町がありません</span>
            </div>
          </div>
        `;
      }

      box.innerHTML = `
        ${comboInfo}
        <table>
          <thead>
            <tr>
              <th>媒体</th>
              <th class="num">${hasCombo ? "接触者平均(Shapley)" : "SHAP"}</th>
              <th class="num">${hasCombo ? "重み付き貢献度" : "貢献度"}</th>
              ${showBudget ? `<th class="num">予算配分(%)</th>` : ``}
            </tr>
          </thead>
          <tbody>
            ${htmlRows}
          </tbody>
        </table>
        <div style="margin-top:6px;">
          ${summaryHtml}
        </div>
      `;
    }
// ★ セレクト変更時 & 再計算ボタン押下時に同じ処理を呼ぶ
    function handleTypeMetricsChange() {
      // 業態指標（上部の SHAP / 貢献度・推測視認率など）
      renderTypeMetrics();
      // 業態変更を反映した「選択した属性の媒体別属性値」を再計算
      updateAttrMetrics();
    }

    $("typeSelect")?.addEventListener("change", handleTypeMetricsChange);
    $("typeRecalcBtn")?.addEventListener("click", handleTypeMetricsChange);

    // 集計（現在のビューの集合を対象）
    function updateAggregates() {
      const currentSet = getActiveSet();
      const count = currentSet.size;
      const codes = Array.from(currentSet).map(String);

      // ★ 「選択にズーム」は常に色付きにするので、ここでは触らない
      const zb = document.getElementById('zoomSelBtn');
      if (zb) {
        // zb.disabled も触らない（常に押せる）
        // zb.classList.toggle('is-active', count > 0); // ← この行は削除
      }

      // 「全て解除」は今まで通り、選択件数で色を切替
      const cb = document.getElementById('clearBtn');
      if (cb) {
        cb.classList.toggle('is-active', count > 0);
      }
      if (!townIndex) {
        $("summary").innerHTML = `<span>選択</span><span>${count} 件（CSV準備中）</span>`;
        $("topStats").innerHTML = "";
        $("allStats").innerHTML = "";
        $("picked").innerHTML = "";
        $("mediaStats").innerHTML = "";
        return;
      }
      const rows = codes.map(c => townIndex.get(c)).filter(Boolean);
      $("summary").innerHTML = `<span>選択</span><span>${count} 件</span>`;

      const numericKeysHere = detectNumericKeys(rows.length ? [rows[0]] : []);
      const sums = {}; for (const k of numericKeysHere) sums[k] = 0;
      for (const r of rows) for (const k of numericKeysHere) sums[k] += Number(r[k]) || 0;
      const avgs = {}; for (const k of numericKeysHere) avgs[k] = count ? (sums[k] / count) : 0;

      // 年齢・年収
      let ageWeighted = 0, agePeople = 0, maleWeighted = 0, malePeople = 0, femaleWeighted = 0, femalePeople = 0;
      const AGE_WIDTH = 5;
      for (const r of rows) for (const [k, v] of Object.entries(r)) {
        const band = parseAgeBand(k, AGE_WIDTH); if (!band) continue;
        const mid = (band.lo + band.hi) / 2, n = Number(v) || 0;
        ageWeighted += mid * n; agePeople += n;
        const t = z2h(k);
        if (/^男/.test(t)) { maleWeighted += mid * n; malePeople += n; }
        else if (/^女/.test(t)) { femaleWeighted += mid * n; femalePeople += n; }
      }
      const avgAge       = agePeople   ? (ageWeighted   / agePeople)   : 0;
      const avgAgeMale   = malePeople  ? (maleWeighted  / malePeople)  : 0;
      const avgAgeFemale = femalePeople? (femaleWeighted / femalePeople): 0;

      let incWeighted = 0, incCount = 0;
      const incomeWidth = detectIncomeWidth(Object.keys(rows[0] || {}));
      for (const r of rows) for (const [k, v] of Object.entries(r)) {
        const band = parseIncomeBand(k, incomeWidth); if (!band) continue;
        const mid = (band.lo + band.hi) / 2, n = Number(v) || 0;
        incWeighted += mid * n; incCount += n;
      }
      const avgIncomeManYen = incCount ? (incWeighted / incCount) : 0;

      let hhTotal = 0, carWeighted = 0, carDen = 0;
      for (const r of rows) {
        const hh = Number(r[HH_TOTAL_KEY]) || 0; hhTotal += hh;
        const carAvg = Number(r[CAR_AVG_KEY]);
        if (isFinite(carAvg)) { carWeighted += carAvg * hh; carDen += hh; }
      }
      const carAvgWeighted = carDen ? (carWeighted / carDen) : 0;
      const popTotal = rows.reduce((a,r)=> a + (Number(r[POP_TOTAL_KEY])||0), 0);

      const topRows = [];
      topRows.push(["平均年齢（中央値推計）",        `${fixed1(avgAge)}歳`]);
      topRows.push(["男性平均年齢（中央値推計）",      `${fixed1(avgAgeMale)}歳`]);
      topRows.push(["女性平均年齢（中央値推計）",      `${fixed1(avgAgeFemale)}歳`]);
      topRows.push(["平均年収（中央値推計）",        `${fixed1(avgIncomeManYen)}万円`]);
      topRows.push(["人口総数 合計",                 fmtU(popTotal, "人")]);
      topRows.push(["世帯総数 合計",                 fmtU(hhTotal, "世帯")]);
      topRows.push(["乗用車保有台数 平均（世帯加重）", `${Number(carAvgWeighted.toFixed(3)).toLocaleString()}台`]);
      $("topStats").innerHTML = topRows.map(([k,v]) => `<div class="row"><span>${k}</span><span>${v}</span></div>`).join("");

      // 媒体（常に「媒体毎の選択町」の合計で集計）
      if (mediaIndex && mediaCodesAllByName) {
        const byName = new Map();
        const isBaseView = (viewMode === "base");
        const baseStr = baseCode ? String(baseCode) : null;

        // ★ 基準町が持っている媒体名の一覧を作る
        const baseMediaNames = new Set();
        if (baseStr && mediaIndex.has(baseStr)) {
          const baseRows = mediaIndex.get(baseStr) || [];
          for (const r of baseRows) {
            const mName = r["媒体名"] ?? "(名称不明)";
            baseMediaNames.add(mName);
          }
        }

        // 媒体マスタに載っている全媒体を対象
        for (const [name, allCodesForMedia] of mediaCodesAllByName.entries()) {
          const explicitSet = mediaViewByName.get(name);
          let codesForSum;

          if (explicitSet && explicitSet.size > 0) {
            // 媒体ビューなどでユーザーが明示的に選択している町
            codesForSum = explicitSet;
          } else if (isBaseView) {
            // ★基準ビューのときだけ、selected を fallback に使う
            const s = new Set();
            for (const code of selected) {
              if (allCodesForMedia.has(String(code))) {
                s.add(String(code));
              }
            }
            codesForSum = s;
          } else {
            // ★媒体ビューで explicitSet が空のときは、
            //   集計対象の町は「なし」だが行は 0 件で残したいので空 Set を使う
            codesForSum = new Set();
          }

          let stat = { 件数: 0, 部数: 0, 料金: 0 };

          // ★ codesForSum が空でも stat は 0 のまま → 行だけは表示される
          for (const code of codesForSum) {
            const rowsForTown = mediaIndex.get(String(code));
            if (!rowsForTown) continue;

            for (const r of rowsForTown) {
              const rName = r["媒体名"] ?? "(名称不明)";
              if (rName !== name) continue;

              stat.件数 += 1;
              stat.部数 += toNumber(r["部数"]);
              stat.料金 += toNumber(r["料金"]);
            }
          }

          // ★ここではもう「全部 0 なら continue」はしない
          byName.set(name, stat);
        }

        if (byName.size) {

          function calcMediaStatOnCodes(mediaName, codeSet, areaSet) {
            const stat = { 件数: 0, 部数: 0, 料金: 0 };
            if (!codeSet || !codeSet.size || !mediaIndex) return stat;
            const m = String(mediaName);
            const aSet = (areaSet && areaSet.size) ? areaSet : null;
            for (const code0 of codeSet) {
              const code = String(code0);
              const rowsForTown = mediaIndex.get(code);
              if (!rowsForTown) continue;
              for (const r of rowsForTown) {
                const rName = r["媒体名"] ?? "(名称不明)";
                if (String(rName) !== m) continue;
                if (aSet) {
                  const a = getMediaAreaCodeFromRow(r, code);
                  if (!aSet.has(String(a))) continue;
                }
                stat.件数 += 1;
                stat.部数 += toNumber(r["部数"]);
                stat.料金 += toNumber(r["料金"]);
              }
            }
            return stat;
          }

          const sorted = Array.from(byName.entries())
            .map(([name, baseStat]) => {
              const dispSet  = getMediaDisplaySet(name);
              const dispAreaSet = getMediaDisplayAreaSet(name);
              const dispStat = calcMediaStatOnCodes(name, dispSet, dispAreaSet);
              return [name, baseStat, dispStat];
            })
            .sort((a, b) => (b[2].料金) - (a[2].料金));

          let totalBu = 0, totalRy = 0, totalN = 0;
          const escapeAttr = (s) => String(s).replace(/"/g, "&quot;");

          const rowsHtml = sorted
            .map(([name, o, disp]) => {
            const enabled = isMediaEnabled(name);
            const params = getSliderParamsForMedia(name);

            // ★表示値は「選択されている店CD（=表示セット）に含まれる分の合計」
            const adjN  = disp.件数;
            const adjBu = disp.部数;
            const adjRy = disp.料金;

            if (enabled) {
              totalN  += adjN;
              totalBu += adjBu;
              totalRy += adjRy;
            }

            const rowClass    = enabled ? "" : "media-row-disabled";
            const btnLabel    = enabled ? "対象" : "除外中";
            const btnOffClass = enabled ? "" : "off";
            const sliderDisabled = (enabled && !params.disabled) ? "" : "disabled";
            const wrapDisabled = (enabled && !params.disabled) ? "" : "disabled";

            const sliderCell = `
                <div class="media-scale-wrap ${wrapDisabled}" title="スライダーで部数（=配布量）の調整">
                  <input type="range"
                         class="media-scale"
                         min="${params.min}" max="${params.max}" step="${params.step}"
                         value="${params.value}"
                         data-media-name="${escapeAttr(name)}"
                         ${sliderDisabled}>
                  <span class="media-scale-val">${params.pct}%</span>
                </div>`;

            return `<tr data-media-name="${escapeAttr(name)}"
                       class="media-row ${rowClass}"
                       title="クリックでこの媒体のビューに切り替え">
              <td>${name}</td>
              <td>${fmtU(adjN, "件")}</td>
              <td>${fmtU(adjBu, "部")}</td>
              <td>${fmtU(adjRy, "円")}</td>
              <td>${sliderCell}</td>
              <td>
                <button type="button"
                        class="media-toggle ${btnOffClass}"
                        data-media-name="${escapeAttr(name)}">${btnLabel}</button>
              </td>
            </tr>`;
          })
          .filter(Boolean)
          .join("");

          $("mediaStats").innerHTML = `
            <table>
              <thead>
                <tr>
                  <th>媒体名</th><th>件数</th><th>部数 合計</th><th>料金 合計</th><th>部数調整</th><th>対象</th>
                </tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
              <tfoot>
                <tr>
                  <th>合計</th>
                  <th>${fmtU(totalN,  "件")}</th>
                  <th>${fmtU(totalBu, "部")}</th>
                  <th>${fmtU(totalRy, "円")}</th>
                  <th></th>
                  <th></th>
                </tr>
              </tfoot>
            </table>`;
        } else {
          $("mediaStats").innerHTML = "（媒体毎の選択町がまだありません）";
        }
      } else {
        $("mediaStats").innerHTML = "（媒体データがありません）";
      }


      // 全数値列（合計・平均）
      const numericKeysHere2 = detectNumericKeys(rows.length ? [rows[0]] : []);
      if (numericKeysHere2.length) {
        const unitMap = { [POP_TOTAL_KEY]:"人", [HH_TOTAL_KEY]:"世帯", [CAR_AVG_KEY]:"台" };
        const body = numericKeysHere2.map(k => `<tr><td>${k}</td><td>${fmtU(sums[k], unitMap[k]||"")}</td><td>${fmtU(avgs[k], unitMap[k]||"")}</td></tr>`).join("");
        $("allStats").innerHTML = `<table><thead><tr><th>項目</th><th>合計</th><th>平均</th></tr></thead><tbody>${body}</tbody></table>`;
      } else { $("allStats").innerHTML = "（数値列が検出できませんでした）"; }

      const list = rows.slice(0, 50).map(r => {
        const name = `${r["市区町村名"] ?? ""} ${r["町丁目名"] ?? ""}`.trim();
        return `<div class="row"><span>${name}</span><span class="code">${r[CODE_KEY]}</span></div>`;
      }).join("");
      $("picked").innerHTML = list || "（未選択）";

      ensureBaseIfMissing();
      updateBaseFeatureState();

      // ★ 業態指標も常に最新にする
      renderTypeMetrics();
      updateAutoButtonHighlight();
      updateAttrMetrics();

    }




    // ★ 提案レポート（印刷 / PDF 用）の生成：HTML を返すだけ
    async function buildProposalReportHtml() {
      try {
        // 念のため最新で集計
        updateAggregates();

        const activeSet = getActiveSet();
        if (!activeSet.size) {
          alert("レポート対象となる町が選択されていません。");
          return null;
        }
        const codes = Array.from(activeSet).map(String);

        // 入力値
        const clientName = document.getElementById("clientNameInput")?.value || "";
        const planTitle  = document.getElementById("planTitleInput")?.value  || "";
        const periodText = document.getElementById("periodInput")?.value     || "";

        const budgetText = document.getElementById("budgetInput")?.value     || "";
        const copiesText = document.getElementById("copiesInput")?.value     || "";
        const distText   = document.getElementById("distInput")?.value       || "";

        const tAge       = document.getElementById("targetAge")?.value       || "";
        const tAgeM      = document.getElementById("targetAgeMale")?.value   || "";
        const tAgeF      = document.getElementById("targetAgeFemale")?.value || "";
        const tIncome    = document.getElementById("targetIncome")?.value    || "";

        const now = new Date();
        const y  = now.getFullYear();
        const m  = String(now.getMonth() + 1).padStart(2, "0");
        const d  = String(now.getDate()).padStart(2, "0");
        const hh = String(now.getHours()).padStart(2, "0");
        const mm = String(now.getMinutes()).padStart(2, "0");

        const viewLabel =
          viewMode === "media"
            ? `媒体ビュー（${currentMediaName || "媒体未選択"}）`
            : "基準ビュー";

        // ==== 地図キャプチャ（現在のビュー＋対象媒体ごと） ====

        const mapImages = [];

        function safeCapture(label) {
          try {
            if (map && map.getCanvas) {
              const url = map.getCanvas().toDataURL("image/png");
              if (url) {
                mapImages.push({ label, dataUrl: url });
              }
            }
          } catch (e) {
            console.warn("地図キャプチャ失敗:", e);
          }
        }

        // 現在の状態を退避
        const savedViewMode        = viewMode;
        const savedCurrentMedia    = currentMediaName;
        const savedMediaViewSet    = new Set(mediaViewSet);
        const savedSelected        = new Set(selected);

        // 1) 現在のビューのまま 1 枚
        await waitMapIdle();
        safeCapture("現在のビュー");

        // 2) 対象 ON の全媒体ごとのビュー
        if (mediaCodesAllByName && mediaIndex) {
          for (const [name, enabled] of mediaEnabledByName.entries()) {
            if (!enabled) continue;
            const allCodesForMedia = mediaCodesAllByName.get(name);
            if (!allCodesForMedia || !allCodesForMedia.size) continue;

            let set = mediaViewByName.get(name);
            if (!set) {
              if (savedSelected.size > 0) {
                set = new Set(
                  [...allCodesForMedia].filter(code => savedSelected.has(String(code)))
                );
              } else {
                set = new Set();
              }
              mediaViewByName.set(name, set);
            }

            // この媒体で選択されている町がなければスキップ
            if (!set || set.size === 0) {
              continue;
            }

            mediaViewSet = new Set(set);
            viewMode = "media";
            currentMediaName = name;

            applyViewSelection();
            updateAggregates();
            updateViewStatus();
            await waitMapIdle();

            safeCapture(`媒体ビュー：${name}`);
          }
        }

        // ★ 状態を元に戻す
        viewMode         = savedViewMode;
        currentMediaName = savedCurrentMedia;
        mediaViewSet     = new Set(savedMediaViewSet);
        selected.clear();
        savedSelected.forEach(c => selected.add(c));
        applyViewSelection();
        updateAggregates();
        updateViewStatus();
        await waitMapIdle();

        // ==== ここからは元の集計ロジック（ほぼそのまま） ====

        const rows = codes
          .map(c => townIndex?.get(c))
          .filter(Boolean);

        if (!rows.length) {
          alert("選択された町の情報が town_master に見つかりませんでした。");
          return null;
        }

        let ageWeighted = 0, agePeople = 0;
        let maleWeighted = 0, malePeople = 0;
        let femaleWeighted = 0, femalePeople = 0;
        let incWeighted = 0, incCount = 0;
        const AGE_WIDTH = 5;
        const incomeWidth = detectIncomeWidth(Object.keys(rows[0] || {}));

        let popTotal = 0;
        let hhTotal  = 0;
        let carWeighted = 0, carDen = 0;

        for (const r of rows) {
          const hhVal = Number(r[HH_TOTAL_KEY]) || 0;
          const pop   = Number(r[POP_TOTAL_KEY]) || 0;
          popTotal += pop;
          hhTotal  += hhVal;

          const carAvg = Number(r[CAR_AVG_KEY]);
          if (isFinite(carAvg)) {
            carWeighted += carAvg * hhVal;
            carDen      += hhVal;
          }

          for (const [k, v] of Object.entries(r)) {
            const bandA = parseAgeBand(k, AGE_WIDTH);
            if (bandA) {
              const mid = (bandA.lo + bandA.hi) / 2;
              const n   = Number(v) || 0;
              ageWeighted += mid * n;
              agePeople   += n;
              const t = z2h(k);
              if (/^男/.test(t)) {
                maleWeighted += mid * n;
                malePeople   += n;
              } else if (/^女/.test(t)) {
                femaleWeighted += mid * n;
                femalePeople   += n;
              }
            }

            const bandI = parseIncomeBand(k, incomeWidth);
            if (bandI) {
              const mid = (bandI.lo + bandI.hi) / 2;
              const n   = Number(v) || 0;
              incWeighted += mid * n;
              incCount    += n;
            }
          }
        }

        const avgAge         = agePeople    ? (ageWeighted   / agePeople)    : 0;
        const avgAgeMale     = malePeople   ? (maleWeighted  / malePeople)   : 0;
        const avgAgeFemale   = femalePeople ? (femaleWeighted/ femalePeople) : 0;
        const avgIncome      = incCount     ? (incWeighted   / incCount)     : 0;
        const carAvgWeighted = carDen       ? (carWeighted   / carDen)       : 0;

        let totalYen = 0;
        let totalCps = 0;
        for (const c of codes) {
          const t = getEnabledMediaTotalsForTown(c);
          totalYen += t.yen;
          totalCps += t.cps;
        }

        const typeSel = document.getElementById("typeSelect");
        let gyotaiName = "";
        let gyotaiViewRate = null;
        let gyotaiVisit    = null;

        if (typeSel && typeSel.value) {
          gyotaiName = typeSel.value;
          const metrics = computeGyotaiMetrics(typeSel.value);
          gyotaiViewRate = metrics.viewRate;
          gyotaiVisit    = metrics.visitRaw;
        }

        const mediaSummary = [];
        if (mediaIndex && mediaCodesAllByName) {
          for (const [name, allCodesForMedia] of mediaCodesAllByName.entries()) {
            if (!isMediaEnabled(name)) continue;

            const explicitSet = mediaViewByName.get(name);
            let codesForSum;

            if (explicitSet && explicitSet.size > 0) {
              codesForSum = explicitSet;
            } else {
              codesForSum = new Set();
              for (const code of selected) {
                if (allCodesForMedia.has(String(code))) {
                  codesForSum.add(String(code));
                }
              }
            }

            if (!codesForSum.size) continue;

            let count = 0, bu = 0, ry = 0;
            for (const code of codesForSum) {
              const rowsForTown = mediaIndex.get(String(code));
              if (!rowsForTown) continue;
              for (const r of rowsForTown) {
                const rName = r["媒体名"] ?? "(名称不明)";
                if (rName !== name) continue;
                if (!isMediaEnabled(rName)) continue;

                count += 1;
                const scale = getMediaScale(rName);
                bu    += toNumber(r["部数"]) * scale;
                ry    += toNumber(r["料金"]) * scale;
              }
            }

            if (count || bu || ry) {
              mediaSummary.push({ name, count, copies: bu, yen: ry });
            }
          }
          mediaSummary.sort((a, b) => b.yen - a.yen);
        }

        const townDetails = [];
        for (const c of codes) {
          const row = townIndex.get(String(c));
          if (!row) continue;

          const name = `${row["市区町村名"] ?? ""} ${row["町丁目名"] ?? ""}`.trim();
          const codeStr = String(row[CODE_KEY] ?? c);
          const pop = Number(row[POP_TOTAL_KEY]) || 0;
          const hhVal  = Number(row[HH_TOTAL_KEY])  || 0;

          let mediaCount = 0, mediaBu = 0, mediaRy = 0;
          if (mediaIndex) {
            const rowsForTown = mediaIndex.get(String(c)) || [];
            for (const r of rowsForTown) {
              const mName = r["媒体名"] ?? "(名称不明)";
              if (!isMediaEnabled(mName)) continue;
              mediaCount += 1;
              const scale = getMediaScale(mName);
              mediaBu    += toNumber(r["部数"]) * scale;
              mediaRy    += toNumber(r["料金"]) * scale;
            }
          }

          townDetails.push({
            name,
            code: codeStr,
            pop,
            hh: hhVal,
            mediaCount,
            mediaBu,
            mediaRy
          });
        }
        townDetails.sort((a, b) => a.name.localeCompare(b.name, "ja"));

        // ▼ グラフ用 HTML（媒体別棒グラフ＋円グラフ、町別散布図）
        let chartsHtml = "";

        if (mediaSummary.length || townDetails.length) {
          // カラーパレット（媒体ごとの色）
          const pieColors = [
            "#3b82f6","#10b981","#f97316","#ec4899",
            "#8b5cf6","#f59e0b","#ef4444","#14b8a6"
          ];

          // --- 媒体別ボリューム（棒グラフ：部数＆料金） ---
          let mediaBarHtml = "";
          if (mediaSummary.length) {
            const maxCopies = Math.max(...mediaSummary.map(m => m.copies || 0));
            const maxYen    = Math.max(...mediaSummary.map(m => m.yen    || 0));

            mediaBarHtml = `
              <div class="chart-card">
                <h2>媒体別ボリューム（棒グラフ）</h2>
                <div class="bar-chart">
                  ${mediaSummary.map(m => {
                    const copiesRatio = maxCopies ? (m.copies / maxCopies * 100) : 0;
                    const yenRatio    = maxYen    ? (m.yen    / maxYen    * 100) : 0;
                    return `
                      <div class="bar-row">
                        <div class="bar-label">${escHtml(m.name)}</div>
                        <div class="bar-wrap">
                          <div class="bar">
                            <span style="width:${copiesRatio.toFixed(1)}%;"></span>
                            <em>${Math.round(m.copies).toLocaleString()}部</em>
                          </div>
                          <div class="bar bar-yen">
                            <span style="width:${yenRatio.toFixed(1)}%;"></span>
                            <em>${Math.round(m.yen).toLocaleString()}円</em>
                          </div>
                        </div>
                      </div>
                    `;
                  }).join("")}
                </div>
                <div class="chart-caption">
                  ※ 部数・料金ともに、それぞれ最大値の媒体を 100% とした相対比です。
                </div>
              </div>
            `;
          }

          // --- 媒体別料金構成比（円グラフ） ---
          let mediaPieHtml = "";
          if (mediaSummary.length) {
            const totalYen = mediaSummary.reduce((s, m) => s + (m.yen || 0), 0);
            if (totalYen > 0) {
              const radius = 80;
              const cx = 100, cy = 100;
              const circumference = 2 * Math.PI * radius;
              let offset = 0;

              const slices = mediaSummary.map((m, idx) => {
                const value = m.yen || 0;
                const ratio = value / totalYen;
                const dash = ratio * circumference;
                const dashArray = `${dash} ${circumference - dash}`;
                const color = pieColors[idx % pieColors.length];
                const slice = `
                  <circle
                    r="${radius}"
                    cx="${cx}"
                    cy="${cy}"
                    fill="transparent"
                    stroke="${color}"
                    stroke-width="32"
                    stroke-dasharray="${dashArray}"
                    stroke-dashoffset="${-offset}"
                  >
                    <title>${escHtml(m.name)}
${Math.round(value).toLocaleString()}円（${(ratio*100).toFixed(1)}%）</title>
                  </circle>
                `;
                offset += dash;
                return slice;
              }).join("");

              const legend = mediaSummary.map((m, idx) => {
                const value = m.yen || 0;
                const ratio = totalYen ? (value / totalYen * 100) : 0;
                const color = pieColors[idx % pieColors.length];
                return `
                  <div class="chart-legend-item">
                    <span class="chart-legend-swatch" style="background:${color};"></span>
                    <span>${escHtml(m.name)}：${Math.round(value).toLocaleString()}円（${ratio.toFixed(1)}%）</span>
                  </div>
                `;
              }).join("");

              mediaPieHtml = `
                <div class="chart-card">
                  <h2>媒体別料金構成比（円グラフ）</h2>
                  <div class="pie-wrapper">
                    <svg class="pie-svg" viewBox="0 0 200 200">
                      <circle r="${radius}" cx="${cx}" cy="${cy}" fill="#f3f4f6"></circle>
                      ${slices}
                    </svg>
                    <div class="chart-legend">
                      ${legend}
                    </div>
                  </div>
                  <div class="chart-caption">
                    ※ 選択中媒体の料金合計を 100% とした構成比です。
                  </div>
                </div>
              `;
            }
          }

          // --- 町別 世帯数×配布部数（散布図） ---
          let scatterHtml = "";
          if (townDetails.length) {
            const maxHh = Math.max(...townDetails.map(t => t.hh || 0));
            const maxBu = Math.max(...townDetails.map(t => t.mediaBu || 0));
            const maxRy = Math.max(...townDetails.map(t => t.mediaRy || 0));
            if (maxHh > 0 && maxBu > 0) {
              const width = 360;
              const height = 240;
              const padLeft = 40, padRight = 10, padTop = 10, padBottom = 30;
              const plotW = width - padLeft - padRight;
              const plotH = height - padTop - padBottom;

              const points = townDetails.map(t => {
                if (!t.hh || !t.mediaBu) return "";
                const x = padLeft + (t.hh / maxHh) * plotW;
                const y = padTop + plotH - (t.mediaBu / maxBu) * plotH;
                const r = 3 + (maxRy ? (t.mediaRy / maxRy) * 4 : 0);
                return `
                  <circle
                    cx="${x.toFixed(1)}"
                    cy="${y.toFixed(1)}"
                    r="${r.toFixed(1)}"
                    fill="rgba(59,130,246,0.75)"
                  >
                    <title>${escHtml(t.name)}
世帯数：${t.hh.toLocaleString()}
部数：${Math.round(t.mediaBu).toLocaleString()}部
料金：${Math.round(t.mediaRy).toLocaleString()}円</title>
                  </circle>
                `;
              }).join("");

              scatterHtml = `
                <div class="chart-card">
                  <h2>町別 世帯数×配布部数（散布図）</h2>
                  <svg class="scatter-svg" viewBox="0 0 ${width} ${height}">
                    <!-- 枠 -->
                    <rect x="${padLeft}" y="${padTop}" width="${plotW}" height="${plotH}" fill="#ffffff" stroke="#e5e7eb" />
                    <!-- 軸ラベル -->
                    <text x="${padLeft + plotW/2}" y="${height - 4}" font-size="11" text-anchor="middle">世帯数</text>
                    <text x="12" y="${padTop + plotH/2}" font-size="11" text-anchor="middle" transform="rotate(-90 12 ${padTop + plotH/2})">配布部数</text>
                    <!-- 目盛（0, 中央, 最大） -->
                    <text x="${padLeft}" y="${height - 14}" font-size="10" text-anchor="start">0</text>
                    <text x="${padLeft + plotW/2}" y="${height - 14}" font-size="10" text-anchor="middle">${Math.round(maxHh/2).toLocaleString()}</text>
                    <text x="${padLeft + plotW}" y="${height - 14}" font-size="10" text-anchor="end">${maxHh.toLocaleString()}</text>

                    <text x="${padLeft - 4}" y="${padTop + plotH}" font-size="10" text-anchor="end">0</text>
                    <text x="${padLeft - 4}" y="${padTop + plotH/2}" font-size="10" text-anchor="end">${Math.round(maxBu/2).toLocaleString()}</text>
                    <text x="${padLeft - 4}" y="${padTop + 8}" font-size="10" text-anchor="end">${maxBu.toLocaleString()}</text>

                    ${points}
                  </svg>
                  <div class="chart-caption">
                    ※ 各点は配布対象となる町を表し、円の大きさは料金規模の目安です。
                  </div>
                </div>
              `;
            }
          }

          if (mediaBarHtml || mediaPieHtml || scatterHtml) {
            chartsHtml = `
              <div class="chart-grid">
                ${mediaBarHtml}
                ${mediaPieHtml}
                ${scatterHtml}
              </div>
            `;
          }
        }

        const titleText = planTitle || "広告配布提案レポート";


        let mediaTableHtml = "";
        if (mediaSummary.length) {
          mediaTableHtml = `
            <table class="data-table">
              <thead>
                <tr>
                  <th>媒体名</th>
                  <th>件数</th>
                  <th>部数合計</th>
                  <th>料金合計</th>
                </tr>
              </thead>
              <tbody>
                ${mediaSummary.map(m => `
                  <tr>
                    <td>${escHtml(m.name)}</td>
                    <td class="num">${m.count.toLocaleString()}件</td>
                    <td class="num">${Math.round(m.copies).toLocaleString()}部</td>
                    <td class="num">${Math.round(m.yen).toLocaleString()}円</td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          `;
        } else {
          mediaTableHtml = `<p class="muted">対象媒体が選択されていません。</p>`;
        }

        let townTableHtml = "";
        if (townDetails.length) {
          townTableHtml = `
            <table class="data-table small">
              <thead>
                <tr>
                  <th>市区町村・町丁目名</th>
                  <th>町丁目コード</th>
                  <th>人口</th>
                  <th>世帯数</th>
                  <th>媒体件数</th>
                  <th>部数合計</th>
                  <th>料金合計</th>
                </tr>
              </thead>
              <tbody>
                ${townDetails.map(t => `
                  <tr>
                    <td>${escHtml(t.name)}</td>
                    <td>${escHtml(t.code)}</td>
                    <td class="num">${t.pop.toLocaleString()}</td>
                    <td class="num">${t.hh.toLocaleString()}</td>
                    <td class="num">${t.mediaCount.toLocaleString()}</td>
                    <td class="num">${Math.round(t.mediaBu).toLocaleString()}</td>
                    <td class="num">${Math.round(t.mediaRy).toLocaleString()}</td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          `;
        }
        // ★ 媒体別グラフ（部数 / 料金）の HTML
        let mediaChartHtml = "";
        if (mediaSummary.length) {
          const maxCopies = Math.max(...mediaSummary.map(m => m.copies || 0));
          const maxYen    = Math.max(...mediaSummary.map(m => m.yen    || 0));

          mediaChartHtml = `
            <div class="card">
              <h2>媒体別グラフ（部数 / 料金）</h2>
              <div class="bar-chart">
                ${mediaSummary.map(m => {
                  const copiesRatio = maxCopies ? (m.copies / maxCopies * 100) : 0;
                  const yenRatio    = maxYen    ? (m.yen    / maxYen    * 100) : 0;
                  return `
                    <div class="bar-row">
                      <div class="bar-label">${escHtml(m.name)}</div>
                      <div class="bar-wrap">
                        <div class="bar bar-copies">
                          <span style="width:${copiesRatio.toFixed(1)}%;"></span>
                          <em>${Math.round(m.copies).toLocaleString()}部</em>
                        </div>
                        <div class="bar bar-yen">
                          <span style="width:${yenRatio.toFixed(1)}%;"></span>
                          <em>${Math.round(m.yen).toLocaleString()}円</em>
                        </div>
                      </div>
                    </div>
                  `;
                }).join("")}
              </div>
              <div class="bar-legend">
                ■ 青：部数（最大媒体を 100% とした比率） ／ ■ 緑：料金
              </div>
            </div>
          `;
        }


        let gyotaiHtml = "";
        if (gyotaiName) {
          const vr = gyotaiViewRate != null ? (gyotaiViewRate * 100).toFixed(1) + "%" : "-";
          const vi = gyotaiVisit    != null ? Math.round(gyotaiVisit).toLocaleString() : "-";
          gyotaiHtml = `
            <div class="card">
              <h2>業態別来店期待</h2>
              <table class="meta-table">
                <tr><th>対象業態</th><td>${escHtml(gyotaiName)}</td></tr>
                <tr><th>推測視認率</th><td>${vr}</td></tr>
                <tr><th>来店期待値指数</th><td>${vi}</td></tr>
              </table>
              <p class="note">※ 選択中配布町と業態に紐づく媒体に基づき算出した指標です。</p>
            </div>
          `;
        }

        let mapBlockHtml = "";
        if (mapImages.length) {
          mapBlockHtml = `
            <div class="map-card">
              <h2>配布エリア地図</h2>
              ${mapImages.map(img => `
                <div style="margin-top:10px;">
                  <div class="muted" style="margin-bottom:4px;">${escHtml(img.label)}</div>
                  <img class="map-image" src="${img.dataUrl}" alt="${escHtml(img.label)}">
                </div>
              `).join("")}
            </div>
          `;
        } else {
          mapBlockHtml = `
            <div class="map-card">
              <h2>配布エリア地図</h2>
              <p class="muted">ブラウザの制限により地図画像を取得できませんでした。必要に応じて画面キャプチャを貼り付けてください。</p>
            </div>
          `;
        }

        const docHtml = `
          <!doctype html>
          <html lang="ja">
          <head>
            <meta charset="utf-8" />
            <title>${escHtml(titleText)}</title>
            <style>
              * { box-sizing: border-box; }
              body {
                font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
                margin: 16px;
                color: #111827;
                background: #f3f4f6;
              }
              .page {
                max-width: 900px;
                margin: 0 auto 24px;
                background: #fff;
                padding: 24px 28px;
                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0,0,0,.08);
              }
              h1 { font-size: 22px; margin: 0 0 8px; }
              h2 {
                font-size: 16px;
                margin: 0 0 6px;
                border-left: 4px solid #3b82f6;
                padding-left: 8px;
              }
              .muted { color:#6b7280; font-size: 12px; }
              .meta-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 8px;
              }
              .meta-table th,
              .meta-table td {
                padding: 4px 8px;
                font-size: 13px;
                border-bottom: 1px solid #e5e7eb;
              }
              .meta-table th {
                width: 140px;
                background: #f9fafb;
                text-align: left;
                color: #374151;
              }
              .meta-table td { text-align: left; }
              .meta-table td.num { text-align: right; }
              .data-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 8px;
                font-size: 12px;
              }
              .data-table.small { font-size: 11px; }
              .data-table th,
              .data-table td {
                border: 1px solid #e5e7eb;
                padding: 3px 6px;
              }
              .data-table th {
                background: #f3f4f6;
                text-align: left;
                white-space: nowrap;
              }
              .data-table td.num {
                text-align: right;
                white-space: nowrap;
              }
              .flex {
                display: flex;
                gap: 16px;
                flex-wrap: wrap;
              }
              .flex > .card { flex: 1 1 260px; }
              .bar-chart {
                margin-top: 8px;
              }

              /* ▼ グラフ用 共通スタイル ▼ */
              .chart-grid {
                display: flex;
                flex-wrap: wrap;
                gap: 16px;
                margin-top: 12px;
              }
              .chart-card {
                flex: 1 1 260px;
                border: 1px solid #e5e7eb;
                border-radius: 10px;
                padding: 10px 12px;
                background: #f9fafb;
              }
              .chart-card h2 {
                margin-top: 0;
                margin-bottom: 8px;
                font-size: 15px;
              }
              .chart-caption {
                margin-top: 4px;
                font-size: 11px;
                color: #6b7280;
              }
              .chart-legend {
                margin-top: 6px;
                font-size: 11px;
                color: #6b7280;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
              }
              .chart-legend-item {
                display: inline-flex;
                align-items: center;
                gap: 4px;
              }
              .chart-legend-swatch {
                width: 12px;
                height: 12px;
                border-radius: 999px;
              }

              /* 棒グラフ（媒体別ボリューム） */
              .bar-chart {
                margin-top: 4px;
              }
              .bar-row {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 6px;
              }
              .bar-label {
                width: 140px;
                font-size: 12px;
                white-space: nowrap;
                color: #4b5563;
              }
              .bar-wrap {
                flex: 1;
              }
              .bar {
                position: relative;
                height: 16px;
                margin-bottom: 4px;
                background: #e5e7eb;
                border-radius: 999px;
                overflow: hidden;
                font-size: 10px;
              }
              .bar span {
                display: block;
                height: 100%;
                background: #3b82f6;  /* 部数 */
              }
              .bar.bar-yen span {
                background: #10b981;   /* 料金 */
              }
              .bar em {
                position: absolute;
                top: 50%;
                left: 8px;
                transform: translateY(-50%);
                font-style: normal;
                color: #111827;
              }

              /* 円グラフ */
              .pie-wrapper {
                display: flex;
                align-items: center;
                gap: 12px;
                flex-wrap: wrap;
              }
              .pie-svg {
                width: 180px;
                height: 180px;
              }

              /* 散布図 */
              .scatter-svg {
                width: 100%;
                max-width: 360px;
                height: 240px;
              }


              .card {
                border: 1px solid #e5e7eb;
                border-radius: 10px;
                padding: 10px 12px;
                background: #f9fafb;
                margin-top: 8px;
              }
              .note { margin-top: 4px; font-size: 11px; color: #6b7280; }
              .print-hint {
                text-align: right;
                font-size: 11px;
                color: #6b7280;
                margin-top: 8px;
              }
              .print-btn {
                display:inline-block;
                margin-bottom:10px;
                padding:6px 10px;
                border-radius:999px;
                border:1px solid #d1d5db;
                background:#f9fafb;
                font-size:12px;
                cursor:pointer;
              }
              .map-card {
                border: 1px solid #e5e7eb;
                border-radius: 10px;
                padding: 10px 12px;
                background: #f9fafb;
                margin-top: 12px;
              }
              .map-image {
                width: 100%;
                max-height: 400px;
                object-fit: contain;
                border-radius: 8px;
                border: 1px solid #e5e7eb;
                background: #fff;
              }
              @media print {
                body { background:#fff; margin:0; }
                .page {
                  box-shadow:none;
                  border-radius:0;
                  margin:0;
                  max-width:none;
                }
                .print-hint, .print-btn { display:none; }
              }
            </style>
          </head>
          <body>
            <div class="page">
              <button class="print-btn" onclick="window.print()">印刷 / PDF に保存</button>
              <h1>${escHtml(titleText)}</h1>
              <div class="muted">作成日：${y}年${m}月${d}日 ${hh}:${mm}</div>

              <table class="meta-table" style="margin-top:12px;">
                <tr><th>提案先</th><td>${escHtml(clientName || "（未入力）")}</td></tr>
                <tr><th>配布期間</th><td>${escHtml(periodText || "（未入力）")}</td></tr>
                <tr><th>ビュー種別</th><td>${escHtml(viewLabel)}</td></tr>
                <tr><th>選択エリア数</th><td>${codes.length.toLocaleString()} 町丁目</td></tr>
              </table>

              <div class="flex" style="margin-top:12px;">
                <div class="card">
                  <h2>配布プラン概要</h2>
                  <table class="meta-table">
                    <tr><th>料金合計</th><td>${Math.round(totalYen).toLocaleString()}円</td></tr>
                    <tr><th>部数合計</th><td>${Math.round(totalCps).toLocaleString()}部</td></tr>
                    <tr><th>人口合計</th><td>${popTotal.toLocaleString()}人</td></tr>
                    <tr><th>世帯数合計</th><td>${hhTotal.toLocaleString()}世帯</td></tr>
                  </table>
                </div>

                <div class="card">
                  <h2>ターゲット / 目標値</h2>
                  <table class="meta-table">
                    <tr><th>料金目標</th><td>${escHtml(budgetText || "（未設定）")}</td></tr>
                    <tr><th>部数目標</th><td>${escHtml(copiesText || "（未設定）")}</td></tr>
                    <tr><th>距離目標</th><td>${escHtml(distText || "（未設定）")}</td></tr>
                    <tr><th>年齢ターゲット</th><td>${escHtml(tAge || "（未設定）")}</td></tr>
                    <tr><th>男女別ターゲット</th><td>${escHtml(tAgeM || "-")} / ${escHtml(tAgeF || "-")}</td></tr>
                    <tr><th>年収ターゲット</th><td>${escHtml(tIncome || "（未設定）")}</td></tr>
                  </table>
                </div>
              </div>

              ${mapBlockHtml}

              <div class="flex" style="margin-top:12px;">
                <div class="card">
                  <h2>配布エリア属性</h2>
                  <table class="meta-table">
                    <tr><th>平均年齢</th><td>${fixed1(avgAge)}歳</td></tr>
                    <tr><th>男性平均年齢</th><td>${fixed1(avgAgeMale)}歳</td></tr>
                    <tr><th>女性平均年齢</th><td>${fixed1(avgAgeFemale)}歳</td></tr>
                    <tr><th>平均年収</th><td>${fixed1(avgIncome)}万円</td></tr>
                    <tr><th>乗用車保有台数（世帯加重平均）</th><td>${Number(carAvgWeighted.toFixed(3)).toLocaleString()}台</td></tr>
                  </table>
                </div>
                ${gyotaiHtml}
              </div>

              ${chartsHtml}   <!-- ★ ここでグラフ3種類をまとめて挿入 -->

              <h2 style="margin-top:18px;">媒体別配布計画</h2>
              ${mediaTableHtml}

              <h2 style="margin-top:18px;">配布エリア一覧</h2>
              ${townTableHtml}

              <div class="print-hint">
                ※ ブラウザの「印刷」から PDF として保存し、そのままお客様への提案資料としてお使いいただけます。
              </div>
            </div>
          </body>
          </html>
        `;

        // ★ ここが重要：ポップアップには書かず、HTML 文字列を返す
        return docHtml;
      } catch (e) {
        console.error("buildProposalReportHtml エラー", e);
        alert("レポート生成中にエラーが発生しました。コンソールを確認してください。");
        return null;
      }
    }


    // ★ レポート出力（CSV）
    function exportReportCsv() {
      // 念のため最新状態に更新
      updateAggregates();

      const now = new Date();
      const y  = now.getFullYear();
      const m  = String(now.getMonth() + 1).padStart(2, "0");
      const d  = String(now.getDate()).padStart(2, "0");
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      const ss = String(now.getSeconds()).padStart(2, "0");
      const filename = `report_${y}${m}${d}_${hh}${mm}${ss}.csv`;

      const rows = [];

      // 基本情報
      const activeSet = getActiveSet();
      const viewLabel =
        viewMode === "media"
          ? `媒体ビュー（${currentMediaName || "媒体未選択"}）`
          : "基準ビュー";

      rows.push(["レポート名", "商圏市場テスト"]);
      rows.push(["ビュー", viewLabel]);
      rows.push(["選択町数", String(activeSet.size)]);
      rows.push(["出力日時", now.toLocaleString("ja-JP")]);
      rows.push([]);

      // サマリ（#topStats の内容をそのまま吸い出し）
      const topStatRows = document.querySelectorAll("#topStats .row");
      if (topStatRows.length) {
        rows.push(["◎サマリ"]);
        topStatRows.forEach(row => {
          const cells = row.querySelectorAll("span");
          if (cells.length >= 2) {
            const label = cells[0].textContent.trim();
            const value = cells[1].textContent.trim();
            rows.push(["サマリ", label, value]);
          }
        });
        rows.push([]);
      }

      // 業態指標（選択されているときだけ）
      const typeSelectEl = document.getElementById("typeSelect");
      if (typeSelectEl && typeSelectEl.value) {
        rows.push(["◎業態指標", typeSelectEl.value]);

        const metricRows = document.querySelectorAll(
          "#typeList .type-metrics-row"
        );
        metricRows.forEach(row => {
          const labelEl = row.querySelector(".type-metrics-label");
          const valueEl = row.querySelector(".type-metrics-value");
          if (!labelEl || !valueEl) return;
          const label = labelEl.textContent.trim();
          const value = valueEl.textContent.trim();
          rows.push(["業態指標", label, value]);
        });

        rows.push([]);
      }

      // 媒体集計（#mediaStats 内の table をそのまま CSV 化）
      const mediaTable = document.querySelector("#mediaStats table");
      if (mediaTable) {
        const headCells = mediaTable.querySelectorAll("thead tr th");
        const header = Array.from(headCells).map(th =>
          th.textContent.trim()
        );

        rows.push(["◎媒体集計"]);
        if (header.length) {
          rows.push(header);
        }

        // tbody
        mediaTable.querySelectorAll("tbody tr").forEach(tr => {
          const tds = tr.querySelectorAll("td");
          const line = Array.from(tds).map(td =>
            td.textContent.trim()
          );
          if (line.length) rows.push(line);
        });

        // tfoot（合計行）
        mediaTable.querySelectorAll("tfoot tr").forEach(tr => {
          const tds = tr.querySelectorAll("th,td");
          const line = Array.from(tds).map(td =>
            td.textContent.trim()
          );
          if (line.length) rows.push(line);
        });

        rows.push([]);
      }

      // 選択町一覧（#picked .row）
      const pickedRows = document.querySelectorAll("#picked .row");
      if (pickedRows.length) {
        rows.push(["◎選択町一覧"]);
        rows.push(["市区町村・町丁目名", "町丁目コード"]);

        pickedRows.forEach(row => {
          const spans = row.querySelectorAll("span");
          if (spans.length >= 2) {
            const name = spans[0].textContent.trim();
            const code = spans[1].textContent.trim();
            rows.push([name, code]);
          }
        });

        rows.push([]);
      }

      // 必要なら：生の選択コード一覧も末尾に追加
      // rows.push(["◎選択町コード一覧"]);
      // getActiveSet().forEach(code => {
      //   rows.push([String(code)]);
      // });

      // Papa.unparse で CSV 文字列に変換（PapaParse を既に読み込んでいる前提）
      const csv = Papa.unparse(rows);

      const blob = new Blob([csv], {
        type: "text/csv;charset=utf-8;"
      });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }


    ["distInput"].forEach(id => {
      const el = $(id);
      el?.addEventListener("change", renderTargetRadius);
    });



    let mediaScaleUpdateTimer = null;

    // ===== Busy overlay control（起動時と同じクルクルを流用 / 描画→重処理）=====
function runWithBusy(runFn, msg="更新中…", delayMs = 0){
  const token = showOverlayBusy(msg);

  const kick = () => {
    // 1) rAF: paint を予約
    requestAnimationFrame(() => {
      // 2) setTimeout: 実際に paint させてから重処理
      setTimeout(() => {
        try { runFn(); }
        finally { hideOverlayBusy(token); }
      }, 0);
    });
  };

  if (delayMs > 0) {
    mediaScaleUpdateTimer = setTimeout(kick, delayMs);
  } else {
    kick();
  }
}


    function getSliderParamsForMedia(mediaName) {
      const m = String(mediaName);
      const enabled = isMediaEnabled(m);

      // 目標ロック中：店CD数スライダー（除外中でも行は消さない）
      if (isGoalLockOn()) {
        const active = !!(GOAL_LOCK && GOAL_LOCK.activeMediaSet && GOAL_LOCK.activeMediaSet.has(m));
        // 非アクティブでも maxCount が取れるように準備（失敗してもOK）
        try { ensureGoalLockMediaPrepared(m); } catch(e) {}

        const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
        const valCount0 = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
        const valCount = active ? valCount0 : 0; // 除外中は 0 表示
        const v = Math.max(0, Math.min(valCount, maxCount));
        const pct = (maxCount > 0) ? Math.round((v / maxCount) * 100) : 0;
        return {
          show: true,
          mode: "count",
          min: 0,
          max: maxCount,
          step: 1,
          value: v,
          pct,
          disabled: (!enabled) || (!active)
        };
      }


      // 通常：％スライダー（5%刻み）
      const scale = getMediaScale(m);
      const pct = Math.round((Number.isFinite(scale) ? scale : 1) * 100);
      const p = Math.max(0, Math.min(100, pct));
      return {
        show: true,
        mode: "pct",
        min: 0,
        max: 100,
        step: 5,
        value: p,
        pct: p,
        disabled: !enabled
      };
    }

    function updateSliderUIForMedia(mediaName) {
      const m = String(mediaName);
      const params = getSliderParamsForMedia(m);
      if (!params.show) return;

      // ★ 同じ媒体のスライダーが複数（媒体別表 / 指標表）あるので、
      //   セレクタ文字列に媒体名を埋め込まず、dataset一致で安全に全て更新する
      const inputs = document.querySelectorAll('input.media-scale[data-media-name]');
      for (let i = 0; i < inputs.length; i++) {
        const input = inputs[i];
        if (String(input.dataset.mediaName || '') !== m) continue;

        input.min = String(params.min);
        input.max = String(params.max);
        input.step = String(params.step);
        input.value = String(params.value);
        input.disabled = !!params.disabled;

        const tr = input.closest('tr[data-media-name]');
        const span = tr ? tr.querySelector('.media-scale-val') : null;
        if (span) span.textContent = String(params.pct) + '%';
      }
    }

    function balanceOtherMediaToKeepGoal(changedMediaName) {
      if (!isGoalLockOn()) return;
      const changed = String(changedMediaName);
      const ty = GOAL_LOCK.targetYen;
      const tc = GOAL_LOCK.targetCopies;
      if (!(ty > 0 || tc > 0)) return;

      // 0部（=v=0）の媒体は常に調整対象外
      // ★両方設定時は、全媒体合計で先に達した側（basisMetric）だけを維持する
      const basis = (ty > 0 && tc > 0)
        ? (GOAL_LOCK.basisMetric || 'yen')
        : (ty > 0 ? 'yen' : 'cps');

      const isHit = (tot) => {
        if (basis === 'yen') return (ty <= 0 || tot.yen >= ty);
        return (tc <= 0 || tot.cps >= tc);
      };
      const isOver = (tot) => {
        if (basis === 'yen') return (ty > 0 && tot.yen > ty);
        return (tc > 0 && tot.cps > tc);
      };

      let total = getCurrentAllMediaTotalsLocked();

      // ---- 1) 不足なら：他媒体（0以外）を均等に +1 して補う ----
      const incCandidates = () => {
        const arr = [];
        for (const m of GOAL_LOCK.activeMediaSet) {
          if (m === changed) continue;
          if (!isMediaEnabled(m)) continue;
          let v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
          if (v <= 0) continue; // 0は調整対象外
          const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
          if (v >= maxCount) continue;
          arr.push(m);
        }
        return arr;
      };

      let guard = 0;
      while (!isHit(total)) {
        const arr = incCandidates();
        if (!arr.length) break;
        for (const m of arr) {
          if (isHit(total)) break;
          const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
          const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
          let v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
          if (v <= 0 || v >= maxCount) continue;

          // +1（prefix の次）
          if (v < gains.length) {
            total.yen += gains[v].yen;
            total.cps += gains[v].cps;
          }
          v += 1;
          GOAL_LOCK.valueCountByMedia.set(m, v);
          recomputeMediaDisplaySet(m);
          updateSliderUIForMedia(m);
        }
        if (guard++ > 100000) break;
      }

      // ---- 2) 余剰なら：他媒体（0以外）を均等に -1 して目標を維持 ----
      const decCandidates = () => {
        const arr = [];
        for (const m of GOAL_LOCK.activeMediaSet) {
          if (m === changed) continue;
          if (!isMediaEnabled(m)) continue;
          let v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
          if (v <= 0) continue; // 0は調整対象外

          const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
          const idx = Math.min(v - 1, gains.length - 1);
          if (idx < 0) continue;

          // この -1 をしても目標を割らないか
          const nextY = total.yen - gains[idx].yen;
          const nextC = total.cps - gains[idx].cps;
          const ok = (basis === 'yen')
            ? (ty <= 0 || nextY >= ty)
            : (tc <= 0 || nextC >= tc);
          if (!ok) continue;
          arr.push(m);
        }
        return arr;
      };

      guard = 0;
      while (isOver(total)) {
        const arr = decCandidates();
        if (!arr.length) break;
        for (const m of arr) {
          if (!isOver(total)) break;
          let v = Math.max(0, Math.round(GOAL_LOCK.valueCountByMedia.get(m) || 0));
          if (v <= 0) continue;

          const gains = GOAL_LOCK.areaGainByMedia.get(m) || [];
          const idx = Math.min(v - 1, gains.length - 1);
          if (idx < 0) continue;

          // もう一度 ok 判定（total が変化しているため）
          const nextY = total.yen - gains[idx].yen;
          const nextC = total.cps - gains[idx].cps;
          const ok = (basis === 'yen')
            ? (ty <= 0 || nextY >= ty)
            : (tc <= 0 || nextC >= tc);
          if (!ok) continue;

          total.yen = nextY;
          total.cps = nextC;
          v -= 1;
          GOAL_LOCK.valueCountByMedia.set(m, v);
          recomputeMediaDisplaySet(m);
          updateSliderUIForMedia(m);
        }
        if (guard++ > 100000) break;
      }
    }

    function applyMediaScaleFromSlider(inputEl, immediate = false) {
      const tr = inputEl.closest('tr[data-media-name]');
      const mediaName = inputEl.dataset.mediaName || (tr ? tr.getAttribute('data-media-name') : null);
      if (!mediaName) return;
      const m = String(mediaName);

      // ------------------------------------------------------------
      // 重要：ドラッグ中(input)は重い再計算を走らせない（ドラッグ不能になるため）
      //       ドラッグを離した(change)タイミングでだけ、クルクル表示＋重い更新を実行する
      // ------------------------------------------------------------

      // 目標ロック中は「店CD数」スライダー
      if (isGoalLockOn() && GOAL_LOCK.activeMediaSet.has(m)) {
        const maxCount = Math.max(0, Math.round(GOAL_LOCK.maxCountByMedia.get(m) || 0));
        let v = Math.round(toNumber(inputEl.value));
        v = Math.max(0, Math.min(maxCount, v));
        if (String(inputEl.value) !== String(v)) inputEl.value = String(v);

        // 値だけ先に保存（ドラッグ中はここまで）
        GOAL_LOCK.valueCountByMedia.set(m, v);

        const pct = (maxCount > 0) ? Math.round((v / maxCount) * 100) : 0;
        const span = tr ? tr.querySelector('.media-scale-val') : null;
        if (span) span.textContent = String(pct) + '%';

        if (!immediate) {
          // ドラッグ中：軽量更新のみ（表示は%だけ追従）
          return;
        }

        // ドラッグを離した：重い更新をまとめて実行
        runWithBusy(() => {
          recomputeMediaDisplaySet(m);
          updateSliderUIForMedia(m);

          // 0まで下げた媒体は調整対象外（balance 側で v<=0 を除外）
          balanceOtherMediaToKeepGoal(m);

          updateAggregates();
          renderTypeMetrics();
          updateAttrMetrics();
          if (viewMode === "media" && currentMediaName) {
            // 他媒体の自動バランスで現在表示中の媒体セットが変わることがあるため、常に再取得して反映
            mediaViewSet = new Set(getMediaDisplaySet(currentMediaName));
            applyViewSelection();
            updateViewStatus();
          }
        }, "更新中…");

        return;
      }

      // 通常：％スライダー
      let pct = toNumber(inputEl.value);
      pct = Math.max(0, Math.min(100, pct));
      if (String(inputEl.value) !== String(pct)) inputEl.value = String(pct);

      // 値だけ保存（ドラッグ中はここまで）
      setMediaScale(m, pct / 100);

      const span = tr ? tr.querySelector('.media-scale-val') : null;
      if (span) span.textContent = String(Math.round(pct)) + '%';

      if (!immediate) {
        // ドラッグ中：軽量更新のみ
        return;
      }

      // ドラッグを離した：重い更新をまとめて実行
      runWithBusy(() => {
        recomputeMediaDisplaySet(m);

        updateAggregates();
        renderTypeMetrics();
        updateAttrMetrics();
        if (viewMode === "media" && currentMediaName) {
          mediaViewSet = new Set(getMediaDisplaySet(currentMediaName));
          applyViewSelection();
          updateViewStatus();
        }
      }, "更新中…");
    }

$("mediaStats").addEventListener("input", (ev) => {
      const el = ev.target;
      if (!(el instanceof HTMLInputElement)) return;
      if (!el.classList.contains("media-scale")) return;
      applyMediaScaleFromSlider(el, false);
    });

    $("mediaStats").addEventListener("change", (ev) => {
      const el = ev.target;
      if (!(el instanceof HTMLInputElement)) return;
      if (!el.classList.contains("media-scale")) return;
      applyMediaScaleFromSlider(el, true);
    });

    $("mediaStats").addEventListener("dblclick", (ev) => {
      const wrap = ev.target.closest(".media-scale-wrap");
      if (!wrap) return;
      const input = wrap.querySelector("input.media-scale");
      if (!input || input.disabled) return;
      input.value = String(input.max || 100);
      applyMediaScaleFromSlider(input, true);
    });

    // ★ attrMetrics 側（指標比較テーブル）に表示されるスライダーでも同じ処理を行う
    //   ※ attrMetrics はテーブルを再描画するので、親コンテナへのイベント委譲にしておく
    const attrMetricsBox = $("attrMetrics");
    if (attrMetricsBox) {
      attrMetricsBox.addEventListener("input", (ev) => {
        const el = ev.target;
        if (!(el instanceof HTMLInputElement)) return;
        if (!el.classList.contains("media-scale")) return;
        applyMediaScaleFromSlider(el, false);
      });

      attrMetricsBox.addEventListener("change", (ev) => {
        const el = ev.target;
        if (!(el instanceof HTMLInputElement)) return;
        if (!el.classList.contains("media-scale")) return;
        applyMediaScaleFromSlider(el, true);
      });

      attrMetricsBox.addEventListener("dblclick", (ev) => {
        const wrap = ev.target.closest(".media-scale-wrap");
        if (!wrap) return;
        const input = wrap.querySelector("input.media-scale");
        if (!input || input.disabled) return;
        input.value = String(input.max || 100);
        applyMediaScaleFromSlider(input, true);
      });
    }

    $("mediaStats").addEventListener("click", (ev) => {
      // 1) まずはトグルボタンのクリックを優先処理
      const toggleBtn = ev.target.closest(".media-toggle");
      if (ev.target.closest(".media-scale") || ev.target.closest(".media-scale-wrap")) {
        return;
      }
      if (toggleBtn) {
        const mediaName = toggleBtn.getAttribute("data-media-name");
        if (!mediaName) return;

        const nowEnabled = isMediaEnabled(mediaName);
        setMediaEnabled(mediaName, !nowEnabled);   // ← まとめて面倒みる

        return; // 行クリック処理には行かない
      }

      // 2) それ以外のクリックは、従来通り「媒体ビューに切り替え」
      const tr = ev.target.closest("tr[data-media-name]");
      if (!tr) return;

      const mediaName = tr.getAttribute("data-media-name");
      if (!mediaName) return;

      currentMediaName = mediaName;

      let set = mediaViewByName.get(mediaName);

      if (!set) {
        const allCodes = mediaCodesAllByName?.get(mediaName) || new Set();

        if (selected.size > 0) {
          set = new Set(
            [...allCodes].filter(code => selected.has(String(code)))
          );
        } else {
          set = new Set();
        }

        mediaViewByName.set(mediaName, set);
      }

      // ★ スライダー倍率に応じた「表示用セット」を作り、地図はその範囲で表示
      runWithBusy(() => {
        recomputeMediaDisplaySet(mediaName);
        mediaViewSet = new Set(getMediaDisplaySet(mediaName));
        viewMode = "media";
        applyViewSelection();
        updateAggregates();
        updateViewStatus();
      }, "ビュー更新中…");
    });


    document.getElementById("attrMetrics")?.addEventListener("change", (ev) => {
      const el = ev.target;

      // ---- 部数調整スライダー（媒体行）----
      if (el && el.classList && el.classList.contains("media-scale")) {
        if (el instanceof HTMLInputElement) {
          applyMediaScaleFromSlider(el, true);
        }
        return;
      }

      // ---- ビュー切り替え（基準の町行＋媒体行）----
      if (el.classList.contains("attr-view-check")) {
        const scopeKind = el.dataset.scopeKind || "";
        const mediaName = el.dataset.mediaName || "";

        // まず全ビュー用チェックを一旦リセットして、この行だけ ON
        document
          .querySelectorAll("#attrMetrics .attr-view-check")
          .forEach(cb => { cb.checked = (cb === el); });

        if (scopeKind === "base") {
          // 基準ビューに戻す
          runWithBusy(() => {
            viewMode = "base";
            applyViewSelection();
            updateAggregates();
            updateViewStatus();
          }, "ビュー更新中…");
          return;
        }

        if (scopeKind === "media" && mediaName) {
          currentMediaName = mediaName;

          let set = mediaViewByName.get(mediaName);
          if (!set) {
            const allCodes = mediaCodesAllByName?.get(mediaName) || new Set();
            if (selected.size > 0) {
              set = new Set(
                [...allCodes].map(String).filter(c => selected.has(c))
              );
            } else {
              set = new Set(allCodes);
            }
            mediaViewByName.set(mediaName, set);
          }

          runWithBusy(() => {
            recomputeMediaDisplaySet(mediaName);
            mediaViewSet = new Set(getMediaDisplaySet(mediaName));
            viewMode = "media";
            applyViewSelection();
            updateAggregates();
            updateViewStatus();
          }, "ビュー更新中…");
          return;
        }

        return;
      }

      // ---- 対象外媒体 ON/OFF ----
      if (el.classList.contains("attr-target-check")) {
        const mediaName = el.dataset.mediaName;
        if (!mediaName) return;
        setMediaEnabled(mediaName, el.checked);
        return;
      }
    });

    // attrMetrics 側のスライダーも「ダブルクリックで100%」
    document.getElementById("attrMetrics")?.addEventListener("dblclick", (ev) => {
      const wrap = ev.target.closest(".media-scale-wrap");
      if (!wrap) return;
      const input = wrap.querySelector("input.media-scale");
      if (!input || input.disabled) return;
      input.value = String(input.max || 100);
      applyMediaScaleFromSlider(input, true);
    });



    // 初期状態
    updateViewStatus();
  </script>
</body>
</html>
